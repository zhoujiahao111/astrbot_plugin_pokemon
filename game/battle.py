# -*- coding: utf-8 -*-
import math
import random
from ..game import bag, pokemon, environment
from ..services import image_data_services, battle_services
from ..models import result
from ..utils import image_utils, text_utils
from ..models.session import 会话类

TYPE_CHART = {
    "一般": {"岩石": 0.5, "幽灵": 0, "钢": 0.5},
    "火": {"火": 0.5, "水": 0.5, "草": 2, "冰": 2, "虫": 2, "岩石": 0.5, "龙": 0.5, "钢": 2},
    "水": {"火": 2, "水": 0.5, "草": 0.5, "地面": 2, "岩石": 2, "龙": 0.5},
    "电": {"水": 2, "电": 0.5, "草": 0.5, "地面": 0, "飞行": 2, "龙": 0.5},
    "草": {"火": 0.5, "水": 2, "草": 0.5, "毒": 0.5, "地面": 2, "飞行": 0.5, "虫": 0.5, "岩石": 2, "龙": 0.5, "钢": 0.5},
    "冰": {"火": 0.5, "水": 0.5, "草": 2, "冰": 0.5, "地面": 2, "飞行": 2, "龙": 2, "钢": 0.5},
    "格斗": {"一般": 2, "冰": 2, "毒": 0.5, "飞行": 0.5, "超能力": 0.5, "虫": 0.5, "岩石": 2, "幽灵": 0, "钢": 2, "妖精": 0.5},
    "毒": {"草": 2, "毒": 0.5, "地面": 0.5, "岩石": 0.5, "幽灵": 0.5, "钢": 0, "妖精": 2},
    "地面": {"火": 2, "电": 2, "草": 0.5, "毒": 2, "飞行": 0, "虫": 0.5, "岩石": 2, "钢": 2},
    "飞行": {"电": 0.5, "草": 2, "格斗": 2, "虫": 2, "岩石": 0.5, "钢": 0.5},
    "超能力": {"格斗": 2, "毒": 2, "超能力": 0.5, "恶": 0, "钢": 0.5},
    "虫": {"火": 0.5, "草": 2, "格斗": 0.5, "毒": 0.5, "飞行": 0.5, "超能力": 2, "幽灵": 0.5, "恶": 2, "钢": 0.5, "妖精": 0.5},
    "岩石": {"火": 2, "冰": 2, "格斗": 0.5, "地面": 0.5, "飞行": 2, "虫": 2, "钢": 0.5},
    "幽灵": {"一般": 0, "超能力": 2, "幽灵": 2, "恶": 0.5},
    "龙": {"龙": 2, "钢": 0.5, "妖精": 0},
    "恶": {"超能力": 2, "幽灵": 2, "恶": 0.5, "格斗": 0.5, "妖精": 0.5},
    "钢": {"水": 0.5, "电": 0.5, "冰": 2, "岩石": 2, "钢": 0.5, "妖精": 2},
    "妖精": {"火": 0.5, "格斗": 2, "毒": 0.5, "龙": 2, "恶": 2, "钢": 0.5}
}

class 战斗类:
    def __init__(
        self,
        会话: 会话类,
        本方队伍宝可梦信息列表: list[pokemon.宝可梦类],
        对方队伍宝可梦信息列表: list[pokemon.宝可梦类],
        本方背包对象: bag.背包管理类,
        对方背包对象: bag.背包管理类,
        本方队伍名称: str,
        对方队伍名称: str,
        本方昵称: str,
        对方昵称: str,
    ):
        self.回合消息块 = None
        self.对战记录列表 = None
        self.天气对象 = None

        self.会话 = 会话
        self.本方队伍宝可梦信息列表 = 本方队伍宝可梦信息列表
        self.对方队伍宝可梦信息列表 = 对方队伍宝可梦信息列表

        self.本方背包对象: bag.背包管理类 = 本方背包对象
        self.对方背包对象: bag.背包管理类 = 对方背包对象

        self.本方队伍名称: str = 本方队伍名称
        self.对方队伍名称: str = 对方队伍名称

        self.本方队伍长度: int = len(self.本方队伍宝可梦信息列表)
        self.对方队伍长度: int = len(self.对方队伍宝可梦信息列表)

        self.本方剩余数量 = self.本方队伍长度 - 1
        self.对方剩余数量 = self.对方队伍长度 - 1

        self.本方昵称 = 本方昵称
        self.对方昵称 = 对方昵称

        self.本方已使用Mega = False
        self.对方已使用Mega = False
        self.本方已使用极巨化 = False
        self.对方已使用极巨化 = False
        self.本方极巨化终止回合 = None
        self.对方极巨化终止回合 = None

    def 返回战斗图方法(
        self,
        背景图名称: str,
        左侧宝可梦数据: dict,
        右侧宝可梦数据: dict,
        本方开启mega: bool = False,
        本方开启极巨化: bool = False,
        对方开启mega: bool = False,
        对方开启极巨化: bool = False,
    ) -> result.结果类:

        结果 = image_data_services.生成战斗界面信息配置方法(
            本方昵称=self.本方昵称,
            对方昵称=self.对方昵称,
            本方队伍名称=self.本方队伍名称,
            对方队伍名称=self.对方队伍名称,
            背景图名称=背景图名称,
            左侧宝可梦数据=左侧宝可梦数据,
            右侧宝可梦数据=右侧宝可梦数据,
            本方队伍长度=self.本方队伍长度,
            对方队伍长度=self.对方队伍长度,
            本方开启mega=本方开启mega,
            本方开启极巨化=本方开启极巨化,
            对方开启mega=对方开启mega,
            对方开启极巨化=对方开启极巨化
        )

        结果 = image_utils.通用图片构造方法(结果.数据信息)

        if not 结果.是否成功:
            return 结果.失败方法("图片位置信息生成失败了")

        return 结果.成功方法(结果.数据信息)

    async def 队伍对战方法(self, 背景图名称: str) -> tuple[list, dict]:
        self.天气对象 = environment.天气类(self.会话)

        # 获取初始上场宝可梦
        本方上场宝可梦对象 = self.本方队伍宝可梦信息列表[0]
        对方上场宝可梦对象 = self.对方队伍宝可梦信息列表[0]

        self.对战记录列表 = [
            [(
                "文本", self.会话.json管理器.随机文案.获取随机文案(
                    "战斗开始",
                    {
                        "我方训练家名称": self.本方昵称, "我方宝可梦名称": 本方上场宝可梦对象.昵称,
                        "对方训练家名称": self.对方昵称, "对方宝可梦名称": 对方上场宝可梦对象.昵称
                    }
                )
            )]
        ]

        回合数 = 1
        while self.本方剩余数量 >= 0 and self.对方剩余数量 >= 0 and 回合数 <= self.会话.最大回合数:
            self.回合消息块 = []
            self.回合消息块.append(("文本", f"--- 第 {回合数} 回合 ---\n"))

            # 回合开始
            self._处理回合开始效果(回合数)

            await self._处理特殊进化(本方上场宝可梦对象, 对方上场宝可梦对象, 回合数, 背景图名称, self.会话.是否生成mega与极巨化图)

            # 核心阶段, 处理进攻逻辑
            await self._执行行动阶段(本方上场宝可梦对象, 对方上场宝可梦对象)

            # 回合结束检查 (濒死和更换宝可梦)
            if 本方上场宝可梦对象.是否濒死:
                本方上场宝可梦对象 = self._处理宝可梦濒死(is_本方=True, 本方上场宝可梦对象=本方上场宝可梦对象, 对方上场宝可梦对象=对方上场宝可梦对象)
                if not 本方上场宝可梦对象:
                    break  # 没有可替换的宝可梦, 输了捏

            if 对方上场宝可梦对象.是否濒死:
                对方上场宝可梦对象 = self._处理宝可梦濒死(is_本方=False, 本方上场宝可梦对象=本方上场宝可梦对象, 对方上场宝可梦对象=对方上场宝可梦对象)
                if not 对方上场宝可梦对象:
                    break  # 对方宝可梦全部阵亡, 赢啦

            回合数 += 1

            self.对战记录列表.append(self.回合消息块)

        战斗结果 = self._处理战斗结束()
        奖励字典 = self._战斗奖励计算(self.会话, 战斗结果)

        return self.对战记录列表, 奖励字典

    def _处理回合开始效果(self, 回合数: int):
        """处理天气等回合开始时的效果。"""
        识别码, 属性字典 = self.天气对象.获取并更新天气方法(回合数)

        if 识别码 and 属性字典:
            self.回合消息块.append(("文本", self.会话.json管理器.随机文案.获取随机文案(识别码, 属性字典) + "\n"))

    async def _处理特殊进化(self, 本方宝可梦, 对方宝可梦, 回合数, 背景图名称, 是否生成图片):
        """检查并执行Mega进化和极巨化。"""
        本方首次Mega, 本方首次极巨化 = self.检查并执行特殊进化(True, 本方宝可梦, 回合数)
        对方首次Mega, 对方首次极巨化 = self.检查并执行特殊进化(False, 对方宝可梦, 回合数)

        # 更新已使用标志
        if 本方首次Mega:
            self.本方已使用Mega = True
        if 本方首次极巨化:
            self.本方已使用极巨化 = True
            self.本方极巨化终止回合 = 回合数 + 3
        if 对方首次Mega:
            self.对方已使用Mega = True
        if 对方首次极巨化:
            self.对方已使用极巨化 = True
            self.对方极巨化终止回合 = 回合数 + 3

        # 终止极巨化
        if self.本方极巨化终止回合 == 回合数:
            本方宝可梦.极巨化是否开启 = False
        if self.对方极巨化终止回合 == 回合数:
            对方宝可梦.极巨化是否开启 = False

        if 是否生成图片 and any((本方首次Mega, 本方首次极巨化, 对方首次Mega, 对方首次极巨化)):
            图片参数字典 = {
                "背景图名称": 背景图名称,
                "左侧宝可梦数据": 本方宝可梦.提取画战斗图所需数据(),
                "右侧宝可梦数据": 对方宝可梦.提取画战斗图所需数据(),
                "本方开启mega": self.本方已使用Mega,
                "本方开启极巨化": self.本方已使用极巨化,
                "对方开启mega": self.对方已使用Mega,
                "对方开启极巨化": self.对方已使用极巨化
            }

            self.回合消息块.append(("图片", 图片参数字典))

            if 本方首次Mega or 对方首次Mega:
                识别码 = "AI决策_超级进化"
                变量字典 = {
                    "名称": 本方宝可梦.昵称 if 本方首次Mega else 对方宝可梦.昵称
                }
            else:
                识别码 = "AI决策_极巨化"
                变量字典 = {
                    "名称": 本方宝可梦.昵称 if 本方首次Mega else 对方宝可梦.昵称
                }

            self.回合消息块.append(("文本", self.会话.json管理器.随机文案.获取随机文案(识别码, 变量字典)))

    async def _执行行动阶段(self, 本方宝可梦, 对方宝可梦):
        """决定行动顺序并依次执行攻击。"""
        # 获取双方最终属性
        print(self.天气对象.天气信息模型)
        本方最终属性, 对方最终属性 = await battle_services.返回双方宝可梦最终属性方法(
            本方宝可梦, 对方宝可梦, self.本方背包对象, self.对方背包对象, self.天气对象.天气信息模型["属性倍率"]
        )

        # 决定攻击顺序
        if self._返回本方是否先攻方法(本方宝可梦, 对方宝可梦):
            攻击方队列 = [
                (本方宝可梦, 本方最终属性, 对方宝可梦, 对方最终属性),
                (对方宝可梦, 对方最终属性, 本方宝可梦, 本方最终属性)
            ]
        else:
            攻击方队列 = [
                (对方宝可梦, 对方最终属性, 本方宝可梦, 本方最终属性),
                (本方宝可梦, 本方最终属性, 对方宝可梦, 对方最终属性)
            ]

        # 依次攻击
        for 攻击方, 攻击方属性, 防守方, 防守方属性 in 攻击方队列:
            # 如果攻击方或防守方已经濒死，则跳过其行动
            if 攻击方.是否濒死 or 防守方.是否濒死:
                continue

            self.回合消息块.append(["文本", self.会话.json管理器.随机文案.获取随机文案("发动攻击", {"名称": 攻击方.昵称})])

            self._执行单次攻击(攻击方, 攻击方属性, 防守方, 防守方属性)
            self.回合消息块.append(["文本", "_______"])

        self.回合消息块.append(["文本", f"{本方宝可梦.昵称}生命值: {本方宝可梦.当前生命值}, {对方宝可梦.昵称}生命值: {对方宝可梦.当前生命值}"])

    def _执行单次攻击(self, 攻击方, 攻击方属性, 防守方, 防守方属性):
        """执行一次完整的攻击、伤害计算和记录。"""
        伤害, 招式数据, 复合识别码, 变量字典 = self.攻击方法(攻击方=攻击方, 防守方=防守方, 攻击方属性=攻击方属性, 防守方属性=防守方属性)
        防守方.承受伤害方法(伤害)

        self.回合消息块.append(["文本", self.会话.json管理器.随机文案.获取随机文案(复合识别码, 变量字典)])

        if 防守方.是否濒死:
            self.回合消息块.append(["文本",  self.会话.json管理器.随机文案.获取随机文案("防守方_濒死", 变量字典)])

    def _处理宝可梦濒死(self, is_本方: bool, 本方上场宝可梦对象, 对方上场宝可梦对象) -> pokemon.宝可梦类 | None:
        """处理宝可梦濒死后的替换逻辑。"""
        下一个宝可梦 = None
        变量字典 = None

        if is_本方:
            self.本方剩余数量 -= 1
            if self.本方剩余数量 >= 0:
                下一个宝可梦 = self._选择下一个上场宝可梦(is_本方=True, 本方上场宝可梦=本方上场宝可梦对象, 对方上场宝可梦=对方上场宝可梦对象)
                变量字典 = {
                    "用户昵称": self.本方昵称,
                    "名称": 下一个宝可梦.昵称
                }
        else:
            self.对方剩余数量 -= 1
            if self.对方剩余数量 >= 0:
                下一个宝可梦 = self._选择下一个上场宝可梦(is_本方=False, 本方上场宝可梦=本方上场宝可梦对象, 对方上场宝可梦=对方上场宝可梦对象)
                变量字典 = {
                    "用户昵称": self.对方昵称,
                    "名称": 下一个宝可梦.昵称
                }

        if 下一个宝可梦:
            self.回合消息块.append(["文本", self.会话.json管理器.随机文案.获取随机文案("替换宝可梦", 变量字典)])
            # print(self.对战记录列表)
        return 下一个宝可梦

    def _处理战斗结束(self) -> bool | None:
        """根据战斗结果生成最终文案。"""
        # 且修改战斗结束判断逻辑, 进行更复杂的判断, 规避平局
        self.对战记录列表.append(self.回合消息块)
        变量字典 = {
            "本方昵称": self.本方昵称,
            "对方昵称": self.对方昵称
        }

        if self.本方剩余数量 > self.对方剩余数量:
            self.对战记录列表.append([("文本", self.会话.json管理器.随机文案.获取随机文案("战斗胜利", 变量字典))])
            return True
        elif self.对方剩余数量 > self.本方剩余数量:
            self.对战记录列表.append([("文本", self.会话.json管理器.随机文案.获取随机文案("战斗失败", 变量字典))])
            return False
        else:
            self.对战记录列表.append([("文本", self.会话.json管理器.随机文案.获取随机文案("战斗平局", 变量字典))])
            return None

    def 攻击方法(self, 攻击方: pokemon.宝可梦类, 防守方: pokemon.宝可梦类, 攻击方属性: dict, 防守方属性: dict) -> tuple:
        招式数据, ai决策识别码 = self._选择招式(攻击方, 防守方, 攻击方属性, 防守方属性)

        for i, 招式字典 in enumerate(攻击方.招式列表):
            # 获取招式名称（字典的第一个key）
            招式名称 = list(招式字典.keys())[0]

            if 招式名称 == 招式数据.get("名称"):
                攻击方.招式列表[i][招式名称]["PP"] = max(0, 攻击方.招式列表[i][招式名称]["PP"] - 1)
                break

        伤害结果 = self._计算伤害(攻击方, 防守方, 攻击方属性, 防守方属性, 招式数据, 是否模拟=False)
        最终伤害 = 伤害结果["伤害"]

        if not 伤害结果["是否命中"]:
            主要事件标签 = "未命中"
            # 优先级 2: 是否暴击
        elif 伤害结果["是否暴击"]:
            主要事件标签 = "暴击"
            # 优先级 3: 属性克制
        elif 伤害结果["克制倍率"] > 1:
            主要事件标签 = "克制"
            # 优先级 4: 属性抵抗
        elif 伤害结果["克制倍率"] < 1:
            主要事件标签 = "抵抗"
            # 优先级 5: 普通命中
        else:
            主要事件标签 = "命中"

        复合识别码 = f"{ai决策识别码}_{主要事件标签}"

        变量字典 = {
            "攻击方": 攻击方.昵称,
            "防守方": 防守方.昵称,
            "招式": 招式数据.get("名称"),
            "伤害": 最终伤害,
            "是否命中": 伤害结果["是否命中"],
            "是否暴击": 伤害结果["是否暴击"],
            "克制倍率": 伤害结果["克制倍率"],
            "本系加成": 伤害结果["本系加成"]
        }
        return 最终伤害, 招式数据, 复合识别码, 变量字典

    def 检查并执行特殊进化(
        self,
        是否为本方: bool,
        宝可梦对象: pokemon.宝可梦类,
        回合数: int
    ) -> tuple[bool, bool]:
        if 是否为本方:
            if self.本方已使用Mega or self.本方已使用极巨化:
                return False, False

            # 腕带 = self.本方背包对象.有无极巨腕带()
            腕带 = True
            # 超级环 = self.本方背包对象.有无超级环()
            超级环 = True
            已Mega = self.本方已使用Mega
            已极巨 = self.本方已使用极巨化
        else:
            if self.对方已使用Mega or self.对方已使用极巨化:
                return False, False

            腕带 = self.对方背包对象.有无极巨腕带()
            超级环 = self.对方背包对象.有无超级环()
            已Mega = self.对方已使用Mega
            已极巨 = self.对方已使用极巨化

        # 权重30
        羁绊分 = (宝可梦对象.心情 / 100) * 30

        # 权重40
        战局分 = 0
        if self.本方剩余数量 == self.对方剩余数量 == 0:
            # 决胜时刻
            战局分 = 40
        elif self.本方剩余数量 == 0:
            # 逆境
            战局分 = 35
        elif self.本方剩余数量 < self.对方剩余数量:
            # 我方处于劣势, 差距越大，分数越高
            战局分 = 20 * (1 - self.本方剩余数量 / self.对方剩余数量)  #
        elif self.本方剩余数量 == self.对方剩余数量 and self.本方剩余数量 <= 3:
            # 势均力敌，但战况激烈
            战局分 = 10

        # 权重20
        生存分 = 0
        剩余血量占比 = 宝可梦对象.当前生命值 / 宝可梦对象.当前属性字典["HP"]
        if 0.4 < 剩余血量占比 <= 0.8:
            # 血量在40%到80%之间，是比较理想的进化时机
            生存分 = 40

        elif 剩余血量占比 > 0.8:
            # 血量高于80%，优势在我
            生存分 = 15
        elif 剩余血量占比 <= 0.4:
            # 血量低于40%，可能要殊死一搏
            生存分 = 10

        # 权值10
        策略分 = 0
        if 回合数 >= 3:
            策略分 = 回合数 * 5

        目标分 = (羁绊分 + 战局分 + 生存分 + 策略分) * 0.75

        # 目标分 = 101
        # ! 临时代码 ! 用于强制启用

        # Mega进化判断
        if 超级环 and not 已Mega and not 已极巨 and 宝可梦对象.mega贴图名称:
            if random.randint(1, 100) < 目标分:
                宝可梦对象.执行mega进化()  # 这个方法会改变宝可梦本场战斗中的种族值、属性、特性等
                if 是否为本方:
                    self.本方已使用Mega = True
                else:
                    self.对方已使用Mega = True
            return True, False

        # 极巨化判断
        elif 腕带 and not 已极巨 and not 已Mega and 宝可梦对象.极巨化贴图名称:
            if random.randint(1, 100) < 目标分:
                宝可梦对象.执行极巨化()
                if 是否为本方:
                    self.本方已使用极巨化 = True
                    self.本方极巨化终止回合 = 回合数 + 3
                    return False, True
                else:
                    self.对方已使用极巨化 = True
                    self.对方极巨化终止回合 = 回合数 + 3

                return False, True

        return False, False

    def _返回本方是否先攻方法(self, 本方上场宝可梦对象, 对方上场宝可梦对象) -> bool:

        先攻值 = 本方上场宝可梦对象.当前属性字典["速度"] - 对方上场宝可梦对象.当前属性字典["速度"]

        先攻值 += self.本方背包对象.返回道具先攻值方法()
        先攻值 -= self.对方背包对象.返回道具先攻值方法()

        if 先攻值 >= 0:
            return True

        return False

    def _选择招式(
        self,
        攻击方: pokemon.宝可梦类,
        防守方: pokemon.宝可梦类,
        攻击方属性: dict,
        防守方属性: dict
    ):
        """
        策略优先级:
        1. 斩杀决策 (可以一击击败对手)
        2. 决战决策 (对手只剩最后一只宝可梦)
        3. 优势决策 (使用属性克制的招式)
        4. 常规决策 (综合伤害与PP选择)
        """
        # 定义一个备用招式，以防宝可梦没有可用招式
        拼命招式 = {
            "名称": "拼命",
            "属性": "一般",
            "分类": "物理",
            "威力": 20,
            "命中": 100,
            "PP": 99999
        }

        # 从攻击方的招式列表中提取并格式化招式数据
        可用招式 = []
        for 招式 in 攻击方.招式列表:
            try:
                招式名称 = list(招式.keys())[0]
                招式详情 = list(招式.values())[0]

                # 确保PP存在且大于0
                if isinstance(招式详情, dict) and 招式详情.get("PP", 0) > 0:
                    可用招式.append({
                        "名称": 招式名称,
                        **招式详情
                    })
            except (IndexError, AttributeError):
                # 处理可能的错误（空字典或无效数据）
                continue

        # 如果没有可用招式（例如所有招式PP为0），则使用“拼命”
        if not 可用招式:
            可用招式 = [拼命招式]

        # 对每个可用招式进行伤害模拟和评估
        招式评估 = []
        for 招式 in 可用招式:
            评估结果 = self._计算伤害(攻击方, 防守方, 攻击方属性, 防守方属性, 招式, 是否模拟=True)
            招式评估.append((招式, 评估结果))  # 存储为 (招式字典, 评估结果)

        # 策略1: 斩杀决策
        # 寻找能够直接击败对手的招式
        可斩杀 = [x for x in 招式评估 if x[1]["伤害"] >= 防守方.当前生命值]
        if 可斩杀:
            # 在可斩杀的招式中，选择伤害最高的一个
            最佳选择 = max(可斩杀, key=lambda x: x[1]["伤害"])
            # 返回选择的招式字典和决策标识
            return 最佳选择[0], "AI决策_斩杀"

        # 策略2: 决战决策
        # 如果对方只剩下最后一只宝可梦，则全力输出
        if self.对方剩余数量 == 1:  # 假设self.对方剩余数量为1代表最后一只
            # 选择伤害期望最高的招式
            最佳选择 = max(招式评估, key=lambda x: x[1]["伤害"])
            return 最佳选择[0], "AI决策_决战"

        # 策略3: 优势决策
        # 寻找属性克制效果大于1的招式
        可克制 = [x for x in 招式评估 if x[1]["克制倍率"] > 1]
        if 可克制:
            # 在克制招式中，选择“伤害 * 克制倍率”最高的，以求最大效果
            最佳选择 = max(可克制, key=lambda x: x[1]["伤害"] * x[1]["克制倍率"])
            return 最佳选择[0], "AI决策_利用克制"

        # 策略4: 常规决策
        # 在没有特殊情况时，综合考虑伤害和PP
        # 优先选择伤害高的，伤害相同时选择PP更多的
        最佳选择 = max(招式评估, key=lambda x: (x[1]["伤害"], x[0]["PP"]))
        return 最佳选择[0], "AI决策_常规"

    def _计算伤害(
        self,
        攻击方: pokemon.宝可梦类,
        防守方: pokemon.宝可梦类,
        攻击方属性: dict,
        防守方属性: dict,
        招式数据: dict,
        是否模拟: bool = False
    ) -> dict:
        """
        计算并返回一次攻击的详细结构化信息，用于后续处理（如AI评估和文案生成）。

        Args:
            攻击方 (pokemon.宝可梦类): 发动攻击的宝可梦。
            防守方 (pokemon.宝可梦类): 承受攻击的宝可梦。
            招式数据 (dict): 使用的招式信息。
            是否模拟 (bool): 若为True，则使用固定的平均值进行计算，用于AI评估。

        Returns:
            dict: 一个包含计算结果的结构化字典。
                  无论成功、失败或异常，都返回固定格式。
        """

        # 预设一个失败/无效的返回结构
        def create_failure_response(tags):
            return {
                "伤害": 0,
                "是否命中": False,
                "是否暴击": False,
                "克制倍率": 1.0,
                "本系加成": 1.0,
                "事件标签": tags,
            }

        try:
            # 1. 数据提取与校验
            招式名称 = 招式数据.get("名称")
            招式属性 = 招式数据.get("属性")
            招式分类 = 招式数据.get("分类")
            招式威力 = 招式数据.get("威力", 0)
            招式命中 = 招式数据.get("命中")

            if not all([招式名称, 招式属性, 招式分类, 招式命中]):
                return create_failure_response(["数据异常"])

            if 招式威力 == 0:
                return create_failure_response(["无伤害招式"])

            事件标签 = []
            是否命中 = True
            if not 是否模拟:
                if random.randint(1, 100) > 招式命中:
                    是否命中 = False
            else:  # 模拟时，命中率低于90的招式按50%概率算，这是一种简化的风险评估
                if 招式命中 < 90:
                    是否命中 = 招式命中 >= 50

            if not 是否命中:
                事件标签.append("未命中")
                return create_failure_response(事件标签)

            事件标签.append("命中")

            if 招式分类 == "物理":
                攻 = 攻击方属性["攻击"]
                防 = 防守方属性["防御"]
            elif 招式分类 == "特殊":
                攻 = 攻击方属性["特攻"]
                防 = 防守方属性["特防"]
            else:  # 理论上不会进入此分支，因为威力为0的招式已过滤
                return create_failure_response(["数据异常", "未知招式分类"])

            # 计算各项加成与系数
            本系加成 = 1.5 if 招式属性 in 攻击方.宝可梦属性列表 else 1.0
            if 本系加成 > 1.0:
                事件标签.append("本系加成")

            # 属性克制倍率
            克制倍率 = self.计算属性克制倍率(招式属性, 防守方.宝可梦属性列表)
            if 克制倍率 > 1:
                事件标签.append("效果绝佳")
            elif 1 > 克制倍率 > 0:
                事件标签.append("效果不佳")
            elif 克制倍率 == 0:
                事件标签.append("没有效果")
                # 如果没有效果，直接返回0伤害
                return {
                    "伤害": 0, "是否命中": True, "是否暴击": False,
                    "克制倍率": 0, "本系加成": 本系加成, "事件标签": 事件标签
                }

            # 暴击判定与系数
            是否暴击 = False
            暴击倍率 = 1.0
            if not 是否模拟:
                if random.random() < (1 / 16):
                    是否暴击 = True
                    暴击倍率 = 1.5
                    事件标签.append("暴击")

            随机系数 = random.uniform(0.85, 1.0) if not 是否模拟 else 0.925  # 模拟时取平均值

            # 核心伤害公式
            削减系数 = 0.4
            基础伤害 = (((攻击方.等级 * 2 / 5 + 2) * 招式威力 * 攻 / 防) / 50) + 2
            最终伤害 = int(基础伤害 * 本系加成 * 克制倍率 * 暴击倍率 * 随机系数 * 削减系数)

            # 确保有效攻击至少造成1点伤害
            if 最终伤害 < 1:
                最终伤害 = 1

            return {
                "伤害": 最终伤害,
                "是否命中": 是否命中,
                "是否暴击": 是否暴击,
                "克制倍率": 克制倍率,
                "本系加成": 本系加成,
                "事件标签": 事件标签,
            }

        except (KeyError, TypeError) as e:
            print("伤害计算异常: " + str(e))
            return create_failure_response(["计算异常"])

    def 计算属性克制倍率(self, 招式属性: str, 防守方属性列表: list) -> float:
        """
        计算招式对一个或多个属性的综合克制倍率。

        Args:
            招式属性 (str): 攻击招式的属性。
            防守方属性列表 (list): 防守方宝可梦的属性列表 (通常为1-2个)。

        Returns:
            float: 最终的伤害倍率 (例如 0, 0.25, 0.5, 1, 2, 4)。
        """
        if not 招式属性 or not 防守方属性列表:
            return 1.0

        total_multiplier = 1.0

        # 获取该招式属性的克制关系字典，如果属性不存在则返回空字典
        attack_effectiveness = TYPE_CHART.get(招式属性, {})

        # 只考虑防守方的前两个属性，以防数据异常
        for defender_type in 防守方属性列表[:2]:
            multiplier = attack_effectiveness.get(defender_type, 1.0)  # 如果没有克制关系，默认为1倍
            total_multiplier *= multiplier

        return total_multiplier

    def _选择下一个上场宝可梦(self, is_本方: bool, 本方上场宝可梦, 对方上场宝可梦) -> pokemon.宝可梦类 | None:
        """
        根据场上情况，智能判断并选择下一个最适合上场的宝可梦。
        主要依据属性克制，其次是等级。

        Args:
            is_本方 (bool): 判断是哪一方需要替换宝可梦。True为本方，False为对方。

        Returns:
            pokemon.宝可梦类 | None: 返回最合适的宝可梦对象，如果没有可战斗的宝可梦则返回 None。
        """
        if is_本方:
            我方队伍 = self.本方队伍宝可梦信息列表
            敌方场上宝可梦 = 对方上场宝可梦
        else:
            我方队伍 = self.对方队伍宝可梦信息列表
            敌方场上宝可梦 = 本方上场宝可梦

        # 筛选出所有健康（未濒死）的宝可梦
        可出战宝可梦列表 = [p for p in 我方队伍 if p.当前生命值 > 0]

        # 处理简单情况
        if not 可出战宝可梦列表:
            raise ValueError("无可用宝可梦但没有触发胜负判断")

        if len(可出战宝可梦列表) == 1:
            return 可出战宝可梦列表[0]  # 只有一个选择，直接返回

        # 为每个可出战的宝可梦计算优势分数
        scored_pokemon_list = []
        敌方属性列表 = 敌方场上宝可梦.宝可梦属性列表

        for 待选宝可梦 in 可出战宝可梦列表:
            我方属性列表 = 待选宝可梦.宝可梦属性列表

            # 如果宝可梦没有属性，则克制倍率为1, 属于例外情况
            if not 我方属性列表:
                最大克制倍率 = 1.0
            else:
                # 计算我方每个属性对敌方的克制倍率，取最大值作为进攻优势
                克制倍率列表 = [self.计算属性克制倍率(t, 敌方属性列表) for t in 我方属性列表]
                最大克制倍率 = max(克制倍率列表)

            # 将（主要分数，次要分数，宝可梦对象）存入列表
            scored_pokemon_list.append((最大克制倍率, 待选宝可梦.等级, 待选宝可梦))

        # 按克制倍率降序，倍率相同则按等级降序
        scored_pokemon_list.sort(key=lambda x: (x[0], x[1]), reverse=True)

        # 返回得分最高的宝可梦
        return scored_pokemon_list[0][2]

    def _战斗奖励计算(self, 会话: 会话类, 战斗结果: bool | None) -> dict:
        """
        根据战斗结果和被击败的对手，计算最终的金钱和经验值奖励。
        引入了基于双方等级差异的经验值修正机制，防止低级挑战高级时经验值过高。

        Args:
            战斗结果 (bool | None): True为胜利, False为失败, None为平局。
        Returns:
            dict: 包含 "金钱" 和 "经验值" 键的奖励字典。
        """
        胜利奖励比例 = 1.0
        平局奖励比例 = 0.3
        战败奖励比例 = 0.1

        我方存活宝可梦列表 = [p for p in self.本方队伍宝可梦信息列表 if not p.是否濒死]
        if not 我方存活宝可梦列表:
            # 如果我方全部濒死（正常情况下战败），则取一个平均值，避免除零错误
            我方平均等级 = sum(p.等级 for p in self.本方队伍宝可梦信息列表) / len(self.本方队伍宝可梦信息列表)
        else:
            我方平均等级 = sum(p.等级 for p in 我方存活宝可梦列表) / len(我方存活宝可梦列表)

        我方平均等级 = max(1, int(我方平均等级))

        # 累加基础奖励
        基础总经验值 = 0
        基础总金钱 = 0
        for 对方宝可梦 in self.对方队伍宝可梦信息列表:
            # 只计算状态为“濒死”的宝可梦
            if 对方宝可梦.是否濒死:
                单次基础经验值 = (对方宝可梦.战胜经验值 * 对方宝可梦.等级) / 7

                等级修正系数 = math.pow(
                    (2 * 对方宝可梦.等级 + 10) / (对方宝可梦.等级 + 我方平均等级 + 10),
                    2.5
                )

                # 对系数进行一些限制，避免极端情况
                等级修正系数 = max(0.1, min(等级修正系数, 2.5))  # 例如，最低不少于10%，最高不多于250%

                # 应用修正系数
                修正后经验值 = 单次基础经验值 * 等级修正系数

                基础总经验值 += 修正后经验值
                基础总金钱 += 对方宝可梦.等级 * 20

        if 战斗结果 is True:
            结果倍率 = 胜利奖励比例
        elif 战斗结果 is None:
            结果倍率 = 平局奖励比例
        else:
            结果倍率 = 战败奖励比例

        return {
            "金钱": int(基础总金钱 * 结果倍率 * (会话.战斗奖励倍率修正 / 100)),
            "经验值": int(基础总经验值 * 结果倍率 * (会话.战斗奖励倍率修正 / 100))
        }