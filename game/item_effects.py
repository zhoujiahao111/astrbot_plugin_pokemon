# coding=utf-8
import time
from datetime import datetime, timedelta

from ..models import result, increment
from ..models.enums import 效果类型类, 操作类, 表名类
from ..core import database
from ..services import team_services, pokemon_services
from ..repository import pokemon_repository
from ..utils import text_utils
from ..dtos import 道具模型, 宝可梦模型
from ..services import move_services

async def 道具生效方法(会话, 匹配名称: str, 数量或序号: str, 用户现有数量: int) -> result.结果类:
    道具数据模型 = 会话.json管理器.道具.根据名称获取物品(匹配名称)

    if not 道具数据模型:
        return result.结果类.失败方法(f"系统中不存在名为【{匹配名称}】的道具。")

    if not 道具数据模型.使用规则.可主动使用:
        return result.结果类.失败方法(f"【{道具数据模型.名称}】不能主动使用哦")

    if not 道具数据模型.效果列表:
        return result.结果类.失败方法(f"错误! 道具【{道具数据模型.名称}】没有定义任何效果")

    # 判断道具类型，解析'数量或序号'参数
    用户消耗数量 = 0
    目标宝可梦ID = None
    是否为进化类道具 = any(效果.效果类型 == 效果类型类.进化 for 效果 in 道具数据模型.效果列表)

    if 是否为进化类道具:
        用户消耗数量 = 1  # 进化道具一次只消耗一个

        结果 = await team_services.获取用户当前队伍信息方法(会话.用户qq, 是否返回队伍ID=False)
            
        if not 结果.是否成功:
            return 结果.失败方法(结果.错误信息)
        
        队伍宝可梦列表 = 结果.数据信息[0]
        if not 队伍宝可梦列表:
            return result.结果类.失败方法("你的队伍中没有宝可梦，无法使用进化道具。")
    
        目标宝可梦 = None
            
        # 尝试将输入作为“序号”处理, 不管昵称是 1-6这种叼毛名称
        try:
            序号 = int(数量或序号)
            if 1 <= 序号 <= len(队伍宝可梦列表):
                目标宝可梦 = 队伍宝可梦列表[序号 - 1]
        except ValueError:
            # 转换成整数失败
            pass
    
        # 如果按序号没有找到，就作为“昵称”处理
        if 目标宝可梦 is None:
            for 宝可梦 in 队伍宝可梦列表:
                if 宝可梦['昵称'] == 数量或序号:
                    目标宝可梦 = 宝可梦
                    break  # 找到第一个匹配的昵称
    

        if 目标宝可梦:
            解析结果 = result.结果类.成功方法(目标宝可梦['主键ID'])
        else:
            解析结果 = result.结果类.失败方法(f"队伍中未找到序号或昵称为 '{数量或序号}' 的宝可梦。")

        队伍宝可梦列表 = 结果.数据信息[0]
        if not 队伍宝可梦列表:
            return result.结果类.失败方法("你的队伍中没有宝可梦，无法使用进化道具。")
        
        if 解析结果.是否成功:
            目标宝可梦ID = 解析结果.数据信息
        else:
            return 解析结果  # 返回获取宝可梦失败的错误信息
    else:
        用户消耗数量 = int(数量或序号) # 对于非进化道具，该参数就是数量


    if 用户现有数量 < 用户消耗数量:
        return result.结果类.失败方法(f"你的【{道具数据模型.名称}】数量不足。")

    if 用户消耗数量 > 1 and not 道具数据模型.使用规则.允许多次使用:
        return result.结果类.失败方法(f"【{道具数据模型.名称}】每次只能使用1个。")
    
    if 用户消耗数量 < 1:
        return result.结果类.失败方法(f"消耗数量不能小于1哦。")

    sql操作列表 = []
    效果文案列表 = []

    for 效果 in 道具数据模型.效果列表:
        if 效果.效果类型 == 效果类型类.即时捕获:
            return result.结果类.失败方法("精灵球只能在遇到宝可梦时自动使用哦。")

        elif 效果.效果类型 == 效果类型类.修改宝可梦出现概率:
            return result.结果类.失败方法(f"【{道具数据模型.名称}】会在下次冒险时自动生效，无需主动使用。")

        # 此类效果都是不能主动使用的
        elif 效果.效果类型 in [效果类型类.先行攻击, 效果类型类.奖励加成, 效果类型类.增加队伍上限, 效果类型类.开启极巨化,
                               效果类型类.开启Mega进化]:
            return result.结果类.失败方法(f"该道具【{道具数据模型.名称}】携带后会自动生效，无需主动使用。")

        elif 效果.效果类型 == 效果类型类.心情恢复:
            结果 = await _执行心情恢复效果(会话, 道具数据模型, 效果.效果参数, 用户消耗数量)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果

        elif 效果.效果类型 == 效果类型类.全队等级提升:
            结果 = await _执行全队等级提升效果(会话, 效果.效果参数, 用户消耗数量)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果

        elif 效果.效果类型 == 效果类型类.添加限时状态:
            结果 = await _执行属性增益效果(会话, 道具数据模型, 效果.效果参数, 用户消耗数量)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果

        elif 效果.效果类型 == 效果类型类.进化:
            if not 目标宝可梦ID:
                return result.结果类.失败方法("系统错误：未能确定进化目标。")

            结果 = await _执行进化效果(会话, 道具数据模型, 目标宝可梦ID)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果
            

        elif 效果.效果类型 == 效果类型类.无:
            return result.结果类.失败方法(f"这个道具【{道具数据模型.名称}】似乎没有什么特别的效果。")

        else:
            if not 道具数据模型.使用规则.可主动使用:
                return result.结果类.失败方法(f"{道具数据模型.名称}不能主动使用哦")
            return result.结果类.失败方法(f"道具【{道具数据模型.名称}】的使用方式很特别，现在还不能这样使用。")

    if not sql操作列表:
        return result.结果类.失败方法(f"道具【{道具数据模型.名称}】没有产生任何效果。")

    db = await database.获取数据库对象()
    结果 = await db.写入方法(sql操作列表)


    if 结果.是否成功:
        # 进化文案通常是独立的，而非进化道具有通用的使用提示
        if 是否为进化类道具:
            return 结果.成功方法("\n".join(效果文案列表))
        else:
            前缀文案 = 会话.json管理器.随机文案.获取随机文案(
                "使用道具", {
                    "用户消耗数量": 用户消耗数量,
                    "量词": 道具数据模型.量词,
                    "名称": 道具数据模型.名称
                }
            )
            return 结果.成功方法(前缀文案 + "\n".join(效果文案列表))
    else:
        return 结果


async def _解析目标宝可梦(会话, 目标标识: str) -> result.结果类:
    """根据队伍序号或昵称，解析出宝可梦的数据库主键ID"""
    队伍结果 = await team_services.获取用户当前队伍信息方法(会话.用户qq, 是否返回队伍ID=False)
    if not 队伍结果.是否成功:
        return 队伍结果

    队伍宝可梦列表 = 队伍结果.数据信息[0]
    if not 队伍宝可梦列表:
        return result.结果类.失败方法("你的队伍中没有宝可梦。")

    目标宝可梦 = None
    # 尝试按序号解析 (1-based index)
    if 目标标识.isdigit():
        序号 = int(目标标识)
        if 1 <= 序号 <= len(队伍宝可梦列表):
            目标宝可梦 = 队伍宝可梦列表[序号 - 1]
        else:
            return result.结果类.失败方法(f"无效的队伍序号【{序号}】，请在1到{len(队伍宝可梦列表)}之间选择。")
    # 尝试按昵称模糊匹配
    else:
        宝可梦昵称列表 = [p["昵称"] for p in 队伍宝可梦列表]
        匹配结果 = text_utils.名称模糊匹配方法(宝可梦昵称列表, 目标标识, 是否返回索引=True)
        if 匹配结果.是否成功:
            目标宝可梦 = 队伍宝可梦列表[匹配结果.数据信息]
        else:
            return result.结果类.失败方法(f"在你的队伍中没有找到名为【{目标标识}】的宝可梦。")

    if 目标宝可梦:
        return result.结果类.成功方法(目标宝可梦["主键ID"])
    else:
        return result.结果类.失败方法("未能确定你想要进化的宝可梦。")
    

async def _执行心情恢复效果(会话, 道具数据模型: 道具模型, 效果参数: dict, 用户消耗数量: int) -> result.结果类:
    结果 = await team_services.获取用户当前队伍信息方法(会话.用户qq, 是否返回队伍ID=False)

    if not 结果.是否成功:
        return 结果.失败方法(结果.错误信息)

    宝可梦ID列表 = [i["主键ID"] for i in 结果.数据信息[0]]

    增加值 = 效果参数["恢复值"] * 用户消耗数量

    操作列表 = [
        {
            "表名": 表名类.宝可梦表,
            "操作": 操作类.更新,
            "数据": {"心情": increment.增量类(增加值, 上限=100)},
            "条件": {"主键ID": 宝可梦ID列表}
        },
        {
            "表名": 表名类.用户物品表,
            "操作": 操作类.更新,
            "数据": {"数量": increment.增量类(-用户消耗数量, 上限=100)},
            "条件": {
                "用户ID": 会话.用户qq,
                "物品名称": 道具数据模型.名称
            }
        }
    ]

    if 结果.是否成功:
        return result.结果类.成功方法((操作列表, f"队伍中的宝可梦心情都增加了{增加值}!"))
    else:
        return 结果.失败方法(结果.错误信息)


async def _执行全队等级提升效果(会话, 效果参数: dict, 用户消耗数量: int) -> result.结果类:
    提升等级数 = int(效果参数.get("提升等级", 1)) * 用户消耗数量

    # 获取队伍初始状态
    结果 = await team_services.获取用户当前队伍信息方法(会话.用户qq, 是否返回队伍ID=False)
    if not 结果.是否成功:
        return 结果

    宝可梦初始信息列表 = 结果.数据信息[0]
    if not 宝可梦初始信息列表:
        return result.结果类.成功方法(
            ([], "队伍中没有宝可梦可供升级。请使用「/pm 入队 序号」来添加宝可梦到默认使用的队伍中"))

    # 初始化状态字典, 保存多次升级时, 每级的临时数据
    宝可梦当前状态字典 = {
        宝可梦['主键ID']: {
            "经验": 宝可梦['经验'],
            "编号": 宝可梦['编号'],
            "昵称": 宝可梦['昵称']
        } for 宝可梦 in 宝可梦初始信息列表
    }

    总操作列表 = []
    总文案列表 = []

    # 逐级模拟升级过程
    for i in range(提升等级数):
        for 宝可梦ID, 当前状态 in list(宝可梦当前状态字典.items()):

            # 使用状态字典的数据来计算, 因为多次升级, 每一级还未写入数据库, 需要使用字典额外保存
            try:
                当前宝可梦模型 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(当前状态['编号'])
                成长速度 = 当前宝可梦模型.成长速度
                当前等级 = pokemon_services.返回宝可梦等级方法(会话, 当前状态['经验'], 成长速度)
            except Exception as e:
                # 图鉴查找失败
                print(f"警告: 查找宝可梦(编号:{当前状态['编号']})图鉴失败: {e}，将跳过其升级。")
                del 宝可梦当前状态字典[宝可梦ID]
                continue

            # 如果已满级，就移除
            if 当前等级 >= 100:
                if i == 0:  # 仅在第一次检查时添加此文案
                    总文案列表.append(f"“{当前状态['昵称']}”已经是满级了。")
                del 宝可梦当前状态字典[宝可梦ID]
                continue

            # 计算升到下一级所需的经验
            升到下一级所需总经验 = pokemon_services.返回到达指定等级的所需经验值方法(
                会话.json管理器.升级需求经验值, 当前等级 + 1, 成长速度
            )
            新增经验 = 升到下一级所需总经验 - 当前状态['经验']

            if 新增经验 <= 0: continue

            # 调用方法获取sql操作列表和文案
            计算结果 = await pokemon_repository.计算经验与相关操作方法(
                会话, 宝可梦ID, 新增经验, 宝可梦信息字典=当前状态
            )

            if not 计算结果.是否成功:
                # 如果单个宝可梦计算失败，记录日志并继续处理下一个，不中断
                print(f"为宝可梦 {当前状态['昵称']}(ID:{宝可梦ID}) 计算升级时失败: {计算结果.错误信息}")
                continue

            单个宝可梦操作列表, 文案信息 = 计算结果.数据信息
            if not 单个宝可梦操作列表: continue

            总操作列表.extend(单个宝可梦操作列表)

            # 构造并收集文案
            文案信息["宝可梦昵称"] = 当前状态['昵称']
            单个宝可梦奖励事件列表 = text_utils.构造宝可梦奖励文案(文案信息, 新增经验)
            for 识别码, 变量字典 in 单个宝可梦奖励事件列表:
                文案 = 会话.json管理器.随机文案.获取随机文案(识别码, 变量字典)
                总文案列表.append(文案 + "\n")

            # 更新状态字典
            宝可梦当前状态字典[宝可梦ID]['经验'] += 新增经验
            if 文案信息.get("是否进化") and 文案信息.get("进化后编号"):
                宝可梦当前状态字典[宝可梦ID]['编号'] = 文案信息['进化后编号']

    if not 总操作列表:
        return result.结果类.成功方法(([], ""))

    最终文案 = "\n".join(总文案列表)
    return result.结果类.成功方法((总操作列表, 最终文案))


async def _执行属性增益效果(会话, 道具数据模型: 道具模型, 效果参数: dict, 用户消耗数量: int) -> result.结果类:
    总持续时间 = 效果参数["持续时间"] * 用户消耗数量
    当前时间 = datetime.now()
    到期日期对象 = 当前时间 + timedelta(seconds=总持续时间)

    # 构建数据库操作列表
    操作列表 = [
        {
            "表名": 表名类.用户物品表,
            "操作": 操作类.更新,
            "数据": {"数量": increment.增量类(-用户消耗数量)},
            "条件": {
                "用户ID": 会话.用户qq,
                "物品名称": 道具数据模型.名称
            }
        },
        {
            "表名": 表名类.激活效果表,
            "操作": 操作类.更新或写入,
            "数据": {
                "到期日期": 到期日期对象
            },
            "条件": {
                "用户ID": 会话.用户qq,
                "物品名称": 道具数据模型.名称
            }
        }
    ]

    # 构建成功提示信息
    加成类型 = 效果参数.get('加成类型', '未知属性')
    加成值 = 效果参数.get('加成值', '未知数值')
    成功信息 = f"队伍宝可梦的【{加成类型}】提升至【{加成值}】倍，效果持续 {总持续时间} 秒。"

    return result.结果类.成功方法((操作列表, 成功信息))

async def _执行进化效果(会话, 道具数据模型: 道具模型, 目标宝可梦ID: int) -> result.结果类:
    db = await database.获取数据库对象()

    # 获取目标宝可梦的当前数据
    结果 = await db.单次查询方法({
        "表名": 表名类.宝可梦表,
        "查询数据": ["经验", "编号", "昵称"],
        "条件": {"主键ID": 目标宝可梦ID}
    })
    if not 结果.是否成功 or not 结果.数据信息:
        return result.结果类.失败方法("未能找到指定的宝可梦。")

    宝可梦信息字典 = 结果.数据信息[0]
    当前经验 = 宝可梦信息字典["经验"]
    当前编号 = 宝可梦信息字典["编号"]
    当前昵称 = 宝可梦信息字典["昵称"]

    # 获取宝可梦图鉴模型和当前等级
    当前宝可梦模型: 宝可梦模型 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(当前编号)
    成长速度 = 当前宝可梦模型.成长速度
    当前等级 = pokemon_services.返回宝可梦等级方法(会话, 当前经验, 成长速度)

    # 检查进化条件是否满足
    进化信息 = 当前宝可梦模型.进化信息
    if not 进化信息:
        return result.结果类.失败方法(f"【{当前昵称}】似乎无法通过使用道具进化。")

    目标进化分支 = None
    进化信息列表 = 进化信息 if isinstance(进化信息, list) else [进化信息]

    for 分支 in 进化信息列表:
        进化道具名称 = 分支.get("进化道具")
        if 进化道具名称 and 进化道具名称 == 道具数据模型.名称:
            # 检查等级
            进化等级 = 分支.get("进化等级")

            if 当前等级 < 进化等级:
                return result.结果类.失败方法(f"【{当前昵称}】的等级不足，需要达到 {进化等级} 级才能使用【{道具数据模型.名称}】进化。")
            
            目标进化分支 = 分支
            break

    if not 目标进化分支:
        return result.结果类.失败方法(f"【{道具数据模型.名称}】对【{当前昵称}】没有效果。")

    # 执行进化
    try:
        索引 = 目标进化分支["进化至_索引"]
        新宝可梦图鉴信息: 宝可梦模型 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(str(索引 + 1))
    except (KeyError, IndexError):
        return result.结果类.失败方法(f"进化配置错误：无法找到【{当前昵称}】的目标进化形态。")

    # 如果昵称是默认名称，则跟随进化改变
    进化后昵称 = 新宝可梦图鉴信息.名称 if 当前昵称 == 当前宝可梦模型.名称 else 当前昵称

    # 5. 修正经验值
    修正后总经验 = pokemon_repository.进化经验值修正(
        会话, 当前经验, 0, 当前等级, 当前宝可梦模型, 新宝可梦图鉴信息
    )

    # 6. 构造进化更新字典
    宝可梦更新数据 = {
        "编号": 新宝可梦图鉴信息.编号,
        "昵称": 进化后昵称,
        "经验": 修正后总经验,
        "心情": increment.增量类(15, 100)
    }

    操作列表 = [{
        "表名": 表名类.宝可梦表,
        "操作": 操作类.更新,
        "数据": 宝可梦更新数据,
        "条件": {"主键ID": 目标宝可梦ID}
    }]

    # 7. 进化后学习新招式
    升级可学会招式列表 = 新宝可梦图鉴信息.升级可学会招式列表
    # 查找新形态在当前等级就能学会，但旧形态在同等级学不会的招式
    新招式列表 = move_services.获取新招式(
        当前等级, 当前等级, 升级可学会招式列表, 会话
    )

    招式文案信息 = {}
    if 新招式列表:
        招式操作列表, 招式文案信息 = move_services.生成学习新招式操作字典方法(
            目标宝可梦ID,
            await move_services.返回招式数据方法(目标宝可梦ID, 会话),
            新招式列表
        )
        if 招式操作列表:
            操作列表.extend(招式操作列表)

    # 8. 消耗道具
    操作列表.append({
        "表名": 表名类.用户物品表,
        "操作": 操作类.更新,
        "数据": {"数量": increment.增量类(-1)},
        "条件": {"用户ID": 会话.用户qq, "物品名称": 道具数据模型.名称}
    })

    # 9. 构造最终文案
    文案 = f"当【{当前昵称}】接触到【{道具数据模型.名称}】时，发出了耀眼的光芒！\n"
    文案 += f"恭喜！你的【{当前昵称}】进化成了【{进化后昵称}】！"

    if 招式文案信息.get("新技能列表"):
        新技能名称列表 = [技能['招式名称'] for 技能 in 招式文案信息["新技能列表"]]
        文案 += f"\n在进化的过程中，它学会了新的招式：{'、'.join(新技能名称列表)}！"

    return result.结果类.成功方法((操作列表, 文案))