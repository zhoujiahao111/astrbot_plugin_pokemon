# coding=utf-8
import time
from datetime import datetime, timedelta

from ..models import result, increment
from ..models.enums import 效果类型类, 操作类, 表名类
from ..core import database
from ..services import team_services, pokemon_services
from ..repository import pokemon_repository
from ..utils import text_utils
from ..dtos import 道具模型


async def 道具生效方法(会话, 匹配名称: str, 用户消耗数量: int, 用户现有数量: int) -> result.结果类:
    道具数据模型 = 会话.json管理器.道具.根据名称获取物品(匹配名称)

    if not 道具数据模型:
        return result.结果类.失败方法(f"系统中不存在名为【{匹配名称}】的道具。")

    # 判断道具是否可使用或数量是否足够
    if not 道具数据模型.使用规则.可主动使用:
        return result.结果类.失败方法(f"【{道具数据模型.名称}】不能主动使用哦")

    if 用户现有数量 < 用户消耗数量:
        return result.结果类.失败方法(f"你的【{道具数据模型.名称}】数量不足。")

    # 新增：处理“允许多次使用”规则
    if 用户消耗数量 > 1 and not 道具数据模型.使用规则.允许多次使用:
        return result.结果类.失败方法(f"【{道具数据模型.名称}】每次只能使用1个。")

    # 校验效果列表是否为空
    if not 道具数据模型.效果列表:
        return result.结果类.失败方法(f"错误! 道具【{道具数据模型.名称}】没有定义任何效果")

    # 根据效果.效果类型进行逻辑分发
    sql操作列表 = []
    效果文案列表 = []

    for 效果 in 道具数据模型.效果列表:
        if 效果.效果类型 == 效果类型类.即时捕获:
            return result.结果类.失败方法("精灵球只能在遇到宝可梦时自动使用哦。")

        elif 效果.效果类型 == 效果类型类.修改宝可梦出现概率:
            return result.结果类.失败方法(f"【{道具数据模型.名称}】会在下次冒险时自动生效，无需主动使用。")

        # 此类效果都是不能主动使用的
        elif 效果.效果类型 in [效果类型类.先行攻击, 效果类型类.奖励加成, 效果类型类.增加队伍上限, 效果类型类.开启极巨化,
                               效果类型类.开启Mega进化]:
            return result.结果类.失败方法(f"该道具【{道具数据模型.名称}】携带后会自动生效，无需主动使用。")

        elif 效果.效果类型 == 效果类型类.心情恢复:
            结果 = await _执行心情恢复效果(会话, 道具数据模型, 效果.效果参数, 用户消耗数量)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果

        elif 效果.效果类型 == 效果类型类.全队等级提升:
            结果 = await _执行全队等级提升效果(会话, 效果.效果参数, 用户消耗数量)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果

        elif 效果.效果类型 == 效果类型类.添加限时状态:
            结果 = await _执行属性增益效果(会话, 道具数据模型, 效果.效果参数, 用户消耗数量)
            if 结果.是否成功:
                sql操作列表.extend(结果.数据信息[0])
                效果文案列表.append(结果.数据信息[1])
            else:
                return 结果

        elif 效果.效果类型 == 效果类型类.进化:
            # 进化类道具需要用户指定目标，逻辑复杂 ! 临时代码 !这是预留的接口
            return result.结果类.失败方法(f"请指定要对哪个宝可梦使用【{道具数据模型.名称}】。")
            # 完整的实现可能需要调用 _执行进化效果(道具模型, 目标宝可梦ID)

        elif 效果.效果类型 == 效果类型类.无:
            return result.结果类.失败方法(f"这个道具【{道具数据模型.名称}】似乎没有什么特别的效果。")

        else:
            if not 道具数据模型.使用规则.可主动使用:
                return result.结果类.失败方法(f"{道具数据模型.名称}不能主动使用哦")
            return result.结果类.失败方法(f"道具【{道具数据模型.名称}】的使用方式很特别，现在还不能这样使用。")

    # 最终执行sql并生成返回的文案
    if not sql操作列表:
        return result.结果类.失败方法(f"{道具数据模型.名称}效果错误, 并没有执行sql哦")

    db = await database.获取数据库对象()

    结果 = await db.写入方法(sql操作列表)

    if 结果.是否成功:
        return 结果.成功方法(
            会话.json管理器.随机文案.获取随机文案(
                "使用道具", {
                    "用户消耗数量": 用户消耗数量,
                    "量词": 道具数据模型.量词,
                    "名称": 道具数据模型.名称
                }
            ) + "\n".join(效果文案列表)
        )

    else:
        # 返回报错信息
        return 结果


async def _执行心情恢复效果(会话, 道具数据模型: 道具模型, 效果参数: dict, 用户消耗数量: int) -> result.结果类:
    结果 = await team_services.获取用户当前队伍信息方法(会话.用户qq, 是否返回队伍ID=False)

    if not 结果.是否成功:
        return 结果.失败方法(结果.错误信息)

    宝可梦ID列表 = [i["主键ID"] for i in 结果.数据信息[0]]

    增加值 = 效果参数["恢复值"] * 用户消耗数量

    操作列表 = [
        {
            "表名": 表名类.宝可梦表,
            "操作": 操作类.更新,
            "数据": {"心情": increment.增量类(增加值, 上限=100)},
            "条件": {"主键ID": 宝可梦ID列表}
        },
        {
            "表名": 表名类.用户物品表,
            "操作": 操作类.更新,
            "数据": {"数量": increment.增量类(-用户消耗数量, 上限=100)},
            "条件": {
                "用户ID": 会话.用户qq,
                "物品名称": 道具数据模型.名称
            }
        }
    ]

    if 结果.是否成功:
        return result.结果类.成功方法((操作列表, f"队伍中的宝可梦心情都增加了{增加值}!"))
    else:
        return 结果.失败方法(结果.错误信息)


async def _执行全队等级提升效果(会话, 效果参数: dict, 用户消耗数量: int) -> result.结果类:
    提升等级数 = int(效果参数.get("提升等级", 1)) * 用户消耗数量

    # 获取队伍初始状态
    结果 = await team_services.获取用户当前队伍信息方法(会话.用户qq, 是否返回队伍ID=False)
    if not 结果.是否成功:
        return 结果

    宝可梦初始信息列表 = 结果.数据信息[0]
    if not 宝可梦初始信息列表:
        return result.结果类.成功方法(
            ([], "队伍中没有宝可梦可供升级。请使用「/pm 入队 序号」来添加宝可梦到默认使用的队伍中"))

    # 初始化状态字典, 保存多次升级时, 每级的临时数据
    宝可梦当前状态字典 = {
        宝可梦['主键ID']: {
            "经验": 宝可梦['经验'],
            "编号": 宝可梦['编号'],
            "昵称": 宝可梦['昵称']
        } for 宝可梦 in 宝可梦初始信息列表
    }

    总操作列表 = []
    总文案列表 = []

    # 逐级模拟升级过程
    for i in range(提升等级数):
        for 宝可梦ID, 当前状态 in list(宝可梦当前状态字典.items()):

            # 使用状态字典的数据来计算, 因为多次升级, 每一级还未写入数据库, 需要使用字典额外保存
            try:
                当前宝可梦模型 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(当前状态['编号'])
                成长速度 = 当前宝可梦模型.成长速度
                当前等级 = pokemon_services.返回宝可梦等级方法(会话, 当前状态['经验'], 成长速度)
            except Exception as e:
                # 图鉴查找失败
                print(f"警告: 查找宝可梦(编号:{当前状态['编号']})图鉴失败: {e}，将跳过其升级。")
                del 宝可梦当前状态字典[宝可梦ID]
                continue

            # 如果已满级，就移除
            if 当前等级 >= 100:
                if i == 0:  # 仅在第一次检查时添加此文案
                    总文案列表.append(f"“{当前状态['昵称']}”已经是满级了。")
                del 宝可梦当前状态字典[宝可梦ID]
                continue

            # 计算升到下一级所需的经验
            升到下一级所需总经验 = pokemon_services.返回到达指定等级的所需经验值方法(
                会话.json管理器.升级需求经验值, 当前等级 + 1, 成长速度
            )
            新增经验 = 升到下一级所需总经验 - 当前状态['经验']

            if 新增经验 <= 0: continue

            # 调用方法获取sql操作列表和文案
            计算结果 = await pokemon_repository.计算经验与相关操作方法(
                会话, 宝可梦ID, 新增经验, 宝可梦信息字典=当前状态
            )

            if not 计算结果.是否成功:
                # 如果单个宝可梦计算失败，记录日志并继续处理下一个，不中断
                print(f"为宝可梦 {当前状态['昵称']}(ID:{宝可梦ID}) 计算升级时失败: {计算结果.错误信息}")
                continue

            单个宝可梦操作列表, 文案信息 = 计算结果.数据信息
            if not 单个宝可梦操作列表: continue

            总操作列表.extend(单个宝可梦操作列表)

            # 构造并收集文案
            文案信息["宝可梦昵称"] = 当前状态['昵称']
            单个宝可梦奖励事件列表 = text_utils.构造宝可梦奖励文案(文案信息, 新增经验)
            for 识别码, 变量字典 in 单个宝可梦奖励事件列表:
                文案 = 会话.json管理器.随机文案.获取随机文案(识别码, 变量字典)
                总文案列表.append(文案 + "\n")

            # 更新状态字典
            宝可梦当前状态字典[宝可梦ID]['经验'] += 新增经验
            if 文案信息.get("是否进化") and 文案信息.get("进化后编号"):
                宝可梦当前状态字典[宝可梦ID]['编号'] = 文案信息['进化后编号']

    if not 总操作列表:
        return result.结果类.成功方法(([], ""))

    最终文案 = "\n".join(总文案列表)
    return result.结果类.成功方法((总操作列表, 最终文案))


async def _执行属性增益效果(会话, 道具数据模型: 道具模型, 效果参数: dict, 用户消耗数量: int) -> result.结果类:
    总持续时间 = 效果参数["持续时间"] * 用户消耗数量
    当前时间 = datetime.now()
    到期日期对象 = 当前时间 + timedelta(seconds=总持续时间)

    # 构建数据库操作列表
    操作列表 = [
        {
            "表名": 表名类.用户物品表,
            "操作": 操作类.更新,
            "数据": {"数量": increment.增量类(-用户消耗数量)},
            "条件": {
                "用户ID": 会话.用户qq,
                "物品名称": 道具数据模型.名称
            }
        },
        {
            "表名": 表名类.激活效果表,
            "操作": 操作类.更新或写入,
            "数据": {
                "到期日期": 到期日期对象
            },
            "条件": {
                "用户ID": 会话.用户qq,
                "物品名称": 道具数据模型.名称
            }
        }
    ]

    # 构建成功提示信息
    加成类型 = 效果参数.get('加成类型', '未知属性')
    加成值 = 效果参数.get('加成值', '未知数值')
    成功信息 = f"队伍宝可梦的【{加成类型}】提升至【{加成值}】倍，效果持续 {总持续时间} 秒。"

    return result.结果类.成功方法((操作列表, 成功信息))