main函数内只有指令函数和大模型相关(llm需要调用架构的, 不太需要自己构建)
以及最终的发送, 最终的错误处理(直接报错), 更上一级的错误处理来自其余类, 返回内容是游戏化的错误提示并返回失败的结果, 如xxx闲逛了一天, 什么都没有获取
职责：
指令路由： 包含所有 @command.on_command 装饰器函数，作为所有功能的唯一入口。
LLM调用： 负责调用框架提供或你自己封装的LLM API。这是因为LLM的调用往往与框架的异步IO、配置管理紧密相关，放在这里最合适。
最终呈现： 将从各个服务收到的“数据”或“半成品”加工成最终要发送给用户的文本和图片。调用 utils 中的工具来完成这一步。
最终错误捕获： 使用 try...except 块捕获所有来自服务层的预期异常，直接给出错误提示。
特点： “薄”控制器。它不包含任何复杂的游戏规则，只负责“调度、调用、呈现、捕获”。


数据库方法单独一个文件, 单例模式
特点： 唯一、底层、专注。其他任何模块都不应直接操作数据库文件，必须通过它。


宠物属性加成和修改一个文件, 单独一个类, 比如  宠物.经验值增加方法(id, 经验值), 方法内部的数据库则是用户数据表之类的
职责：
封装所有与宠物 核心属性 相关的业务逻辑。
提供高级方法如 add_experience(pet_id, amount)。此方法内部会处理等级提升、进化检查等一系列连锁反应。
还应包括 change_mood(pet_id, value)、get_pet_full_details(pet_id) 等。
特点： 面向对象的类设计，每个方法都是一个完整的业务操作。它会频繁调用 database.py。


战斗也是单独一个类, 比如自动计算战斗伤害的公式
职责：
封装所有与战斗相关的计算和模拟。
核心方法可能是 simulate_6v6(team_a, team_b)，它接收两个队伍的数据，返回一个包含详细过程和结果的 BattleResult 对象。
它不关心如何展示战斗，只关心如何计算战斗。
特点： 纯计算，无IO。
可以生成 类格斗游戏界面的战斗图


冒险, 玩耍之类的互动可能是一个类, 也可能是纯面向过程, 功能应该是提供随机的文案模版/提示词, 返回到main文件里, 最终发送给大模型
大模型返回结果并处理
职责：
生成Prompt： 这是它的核心职责。根据玩家状态和目标地点，设计出高质量的、引导性强的Prompt模板。
处理“奇遇”： 内部包含随机算法，决定本次冒险是否会遇到宠物、捡到道具。
返回“半成品”： 它不直接调用LLM，而是将生成的Prompt和奇遇判定的内部结果打包，返回给 main.py。
特点： 创意和规则的结合体。




数据类型类, 用于规范各种方法和类的 交互格式
职责：
定义所有模块间交互所需的数据结构，如 PetData, BattleResult, AdventurePrompt 等。
使用 dataclasses 或 Pydantic 来实现。
特点： 项目的“接口协议”，确保数据在不同模块间传递时标准、统一、不出错。


工具类, 提供基础的函数, 比如图片生成, 文字转图片等等
职责：
image_generator.py: 封装所有Pillow相关的图片生成代码。接收 models.py 中定义的数据对象，输出图片。
text_formatter.py: (可选) 如果你需要处理复杂的文本格式化，可以放在这里。
特点： 纯粹的功能性代码，与游戏规则完全解耦，可被任何模块按需调用。

可提供gif类选项
宝可梦贴图上下浮动几个px, 底部有简单阴影

