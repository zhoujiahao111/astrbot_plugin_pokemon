# coding=utf-8
from ..utils import text_utils
from ..models import result, increment
from ..core import database
from ..models.enums import 表名类, 操作类
from ..services import team_services, pokemon_services, move_services
from ..models.session import 会话类
from ..dtos import 宝可梦模型

async def 执行宝可梦改名方法(
    会话: 会话类,
    新名称: str,
    位置序号: int = None,
    主键ID: int = None,
    是否检测违禁词: bool = True
) -> result.结果类:
    db = await database.获取数据库对象()

    if not 主键ID:
        if 位置序号 not in range(1, 7):
            return result.结果类.失败方法("位置错误哦, 队内最多6个宝可梦呢, 第一个宝可梦的位置就是1哦")

        if len(新名称) > 10:
            return result.结果类.失败方法("名称太长啦")

        # 违禁词检测
        if 是否检测违禁词:
            if not 会话.json管理器.违禁词.文本是否通过审核(新名称):
                return result.结果类.失败方法(会话.json管理器.随机文案.获取随机文案("未通过审核", {}))

        # 获取用户指定的宝可梦的ID
        结果 = await db.join查询方法(
            查询字段=[db.获取数据表方法(表名类.队伍成员表).宝可梦ID],
            主模型=表名类.用户表,
            连接信息=[
                {
                    '模型': 表名类.队伍成员表,
                    '条件': db.获取数据表方法(表名类.用户表).当前队伍ID == db.获取数据表方法(表名类.队伍成员表).队伍ID,
                }
            ],
            筛选条件=[
                db.获取数据表方法(表名类.用户表).用户ID == 会话.用户qq,
                db.获取数据表方法(表名类.队伍成员表).位置索引 == 位置序号 - 1
            ]
        )

        if 结果.是否成功:
            宝可梦ID = 结果.数据信息[0]['宝可梦ID'] if 结果 else None
            if not 宝可梦ID:
                print("没有找到主键ID, 返回了空结果")
                return result.结果类.失败方法("查询完成但是没有找到对应的宝可梦")
        else:
            print("没有找到主键ID, 错误信息: " + 结果.错误信息)
            return result.结果类.失败方法("没有找到对应的宝可梦哦")

    # 更新名称
    结果 = await db.写入方法([
        {
            "表名": 表名类.宝可梦表,
            "操作": 操作类.更新,
            "数据": {"昵称": 新名称},
            "条件": {"主键ID": 主键ID if 主键ID else 结果.数据信息[0]["宝可梦ID"]}
        }
    ])

    if 结果.是否成功:
        if 主键ID:
            return result.结果类.成功方法(f"管理员大人, 已成功将主键ID为{主键ID}的宝可梦重命名为 {新名称}")
        else:
            return result.结果类.成功方法(f"完成! 伙伴的新名称是: {新名称}")

    print("名称更新失败, 错误信息: " + str(结果.错误信息))
    return result.结果类.失败方法("唉, 名称没有更新成功")


async def 执行查看盒子方法(会话: 会话类, 页数: int) -> result.结果类:
    # 获取所有未加入队伍的宝可梦
    结果 = await team_services.获取未加入队伍宝可梦(会话=会话)
    
    if 结果.是否成功:
        盒子宝可梦信息列表: list = 结果.数据信息

    else:
        print(f"获取未入队宝可梦失败" + 结果.错误信息)
        return result.结果类.失败方法("失误了, 统计盒子里的宝可梦时失败了")

    if not 盒子宝可梦信息列表:
        return result.结果类.失败方法("当前盒子里没有未入队的宝可梦哦")

    最终页 = (len(盒子宝可梦信息列表) + 19) // 20
    页数 = min(max(最终页, 1), 页数)

    return result.结果类.成功方法((盒子宝可梦信息列表, 最终页, 页数))


def 宝可梦进化判断(
    会话,
    当前昵称: str,
    当前宝可梦模型: 宝可梦模型,
    旧等级: int,
    经验增加后的等级: int
) -> tuple:
    """
    判断宝可梦是否满足进化条件，并返回进化相关信息。
    """
    进化信息 = 当前宝可梦模型.进化信息

    # 检查是否存在进化信息，如果不存在，直接返回“不进化”的默认值
    if not 进化信息:
        return 当前宝可梦模型, {}, {"是否进化": False, "是分支进化": False}

    # 处理分支进化
    if isinstance(进化信息, list):
        可选进化列表 = []
        for 进化分支 in 进化信息:
            进化等级 = 进化分支.get("进化等级")

            # [核心修改] 这是实现“只触发一次”的关键逻辑
            # 只有当宝可梦的等级在这次升级中“跨过”了进化等级线，才将其视为一个新的可进化选项
            if 进化等级 is not None and 旧等级 < 进化等级 <= 经验增加后的等级:
                try:
                    索引 = 进化分支["进化至_索引"]
                    新宝可梦信息: 宝可梦模型 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(str(索引 + 1))

                    可选进化列表.append({
                        "新编号": 新宝可梦信息.编号,
                        "新名称": 新宝可梦信息.名称
                    })
                except (KeyError, IndexError):
                    continue

        # 只有当本次升级解锁了至少一个新的分支时，才返回提示
        if 可选进化列表:
            进化文案信息 = {
                "是否进化": False,
                "是分支进化": True,
                "分支选项": 可选进化列表
            }
            return 当前宝可梦模型, {}, 进化文案信息
        else:
            # 如果没有跨过任何新的进化等级，则不发送任何进化信号
            return 当前宝可梦模型, {}, {"是否进化": False, "是分支进化": False}

    # 处理单向进化
    if isinstance(进化信息, dict):
        进化等级 = 进化信息.get("进化等级")
        索引 = 进化信息.get("进化至_索引")

        # 检查是否满足进化等级和配置是否有效
        if 进化等级 is None or 索引 is None or 经验增加后的等级 < 进化等级:
            return 当前宝可梦模型, {}, {"是否进化": False, "是分支进化": False}

        try:
            新宝可梦信息 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(str(索引 + 1))
        except IndexError:
            print(f"严重错误：单一进化索引 {索引} 超出了图鉴列表的范围！请检查配置。")
            return 当前宝可梦模型, {}, {"是否进化": False, "是分支进化": False}

        # 如果昵称是默认名称，则跟随进化改变
        进化后昵称 = 新宝可梦信息["名称"] if 当前昵称 == 当前宝可梦模型.名称 else 当前昵称

        数据库更新字典 = {
            "编号": 新宝可梦信息["编号"],
            "昵称": 进化后昵称,
            "心情": increment.增量类(15, 100)
        }

        # 构造单向进化的文案信息
        进化文案信息 = {
            "是否进化": True,
            "是分支进化": False,
            "旧编号": 当前宝可梦模型.编号,
            "旧名称": 当前宝可梦模型.名称,
            "新编号": 新宝可梦信息["编号"],
            "新名称": 新宝可梦信息["名称"],
            "旧昵称": 当前昵称,
            "新昵称": 进化后昵称
        }

        # 返回新的宝可梦模型、进化所需的数据库更新、以及进化文案信息
        return 新宝可梦信息, 数据库更新字典, 进化文案信息

    return 当前宝可梦模型, {}, {"是否进化": False, "是分支进化": False}


def 进化经验值修正(会话, 当前经验, 新增经验, 经验增加后的等级, 当前宝可梦模型, 新宝可梦图鉴信息) -> int:
    """
    计算宝可梦进化后，为了保持 新等级 和 经验条进度 不变，所应有的 最终总经验值
    """
    当前成长速度 = 当前宝可梦模型.成长速度
    新成长速度 = 新宝可梦图鉴信息.成长速度

    总经验_升级后 = 当前经验 + 新增经验

    # 如果成长速度不变，或者已经满级，则总经验值就是升级后的总经验值，无需修正
    if 当前成长速度 == 新成长速度 or 经验增加后的等级 >= 100:
        return 总经验_升级后

    旧_本级所需经验 = pokemon_services.返回到达指定等级的所需经验值方法(
        会话.json管理器.升级需求经验值, 经验增加后的等级, 当前成长速度
    )
    旧_下级所需经验 = pokemon_services.返回到达指定等级的所需经验值方法(
        会话.json管理器.升级需求经验值, 经验增加后的等级 + 1, 当前成长速度
    )

    旧_等级经验跨度 = 旧_下级所需经验 - 旧_本级所需经验

    # 避免除以零的错误
    if 旧_等级经验跨度 <= 0:
        # 如果出现异常情况（如满级），直接返回在新成长速度下达到该等级所需的经验
        return pokemon_services.返回到达指定等级的所需经验值方法(
            会话.json管理器.升级需求经验值, 经验增加后的等级, 新成长速度
        )

    当前进度经验 = 总经验_升级后 - 旧_本级所需经验
    升级进度比例 = 当前进度经验 / 旧_等级经验跨度

    新_本级所需经验 = pokemon_services.返回到达指定等级的所需经验值方法(
        会话.json管理器.升级需求经验值, 经验增加后的等级, 新成长速度
    )
    新_下级所需经验 = pokemon_services.返回到达指定等级的所需经验值方法(
        会话.json管理器.升级需求经验值, 经验增加后的等级 + 1, 新成长速度
    )

    新_等级经验跨度 = 新_下级所需经验 - 新_本级所需经验

    修正后总经验 = 新_本级所需经验 + (新_等级经验跨度 * 升级进度比例)

    return int(修正后总经验)


async def 计算经验与相关操作方法(会话: 会话类, 宝可梦ID: int, 新增经验: int, 宝可梦信息字典: dict = {}) -> result.结果类:
    """
    计算宝可梦经验增加后的相关操作，并返回数据库操作列表和文案信息字典。
    """
    if 新增经验 <= 0:
        return result.结果类.成功方法([])

    db = await database.获取数据库对象()

    if not 宝可梦信息字典:
        结果 = await db.单次查询方法({
            "表名": 表名类.宝可梦表,
            "查询数据": ["经验", "编号", "昵称"],
            "条件": {"主键ID": 宝可梦ID}
        })

        if not 结果.是否成功:
            return 结果.失败方法(结果.错误信息)

        宝可梦信息字典 = 结果.数据信息[0]

    try:
        当前经验 = 宝可梦信息字典["经验"]
        当前编号 = 宝可梦信息字典["编号"]
        当前昵称 = 宝可梦信息字典["昵称"]

    except Exception as e:
        return result.结果类.失败方法("查询宝可梦信息后, 解析失败")

    当前宝可梦模型: 宝可梦模型 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(当前编号)
    成长速度 = 当前宝可梦模型.成长速度

    当前等级 = pokemon_services.返回宝可梦等级方法(会话, 当前经验, 成长速度)

    if 当前等级 >= 100:
        # 满级宝可梦，不进行后续计算和操作
        return result.结果类.成功方法(([], {"旧等级": 100, "新等级": 100}))

    # 计算经验增加后的等级
    经验增加后的等级 = pokemon_services.返回宝可梦等级方法(会话, 当前经验 + 新增经验, 成长速度)

    文案信息字典 = {
        # 初始化文案信息中的状态标志
        "是否进化": False,
        "是分支进化": False,
        "是否升级": False,
        "是否学习": False,
        "旧等级": 当前等级,
        "新等级": 经验增加后的等级,
        "新技能列表": [],
        "被遗忘技能列表": [],
    }

    操作列表 = []
    # 经验值更新是基础操作
    更新数据 = {"经验": increment.增量类(新增经验)}

    # 判断是否升级，并处理相关逻辑
    if 经验增加后的等级 > 当前等级:
        文案信息字典["是否升级"] = True

        # 处理进化逻辑
        进化后图鉴信息, 进化数据, 进化文案信息 = 宝可梦进化判断(
            会话=会话,
            当前昵称=当前昵称,
            当前宝可梦模型=当前宝可梦模型,
            旧等级=当前等级,
            经验增加后的等级=经验增加后的等级
        )

        文案信息字典.update(进化文案信息)

        if 文案信息字典.get("是否进化") and not 文案信息字典.get("是分支进化"):
            # 只有单向进化才执行数据库操作，并更新图鉴编号
            if '经验' in 进化数据:
                # 确保进化数据不包含经验键，防止与前面的增量更新冲突
                print(f"警告: 来自'宝可梦进化判断'的进化数据中包含'经验'键，已自动忽略以防止重复增加。")
                del 进化数据['经验']

            # 将进化所需的数据（如新编号、新昵称）合并到我们的主更新字典中
            更新数据.update(进化数据)

        elif 文案信息字典.get("是分支进化"):
            # 从文案信息中获取分支选项列表
            分支选项列表 = 文案信息字典.get("分支选项", [])

            if 分支选项列表:
                文案信息字典["分支进化选项文本"] = "\n".join([f"· {选项['新名称']}" for 选项 in 分支选项列表])

        图鉴信息用于技能判断 = 进化后图鉴信息 if (文案信息字典.get("是否进化") and not 文案信息字典.get("是分支进化")) else 当前宝可梦模型
        升级可学会招式列表 = 图鉴信息用于技能判断.升级可学会招式列表

        新招式列表 = move_services.获取新招式(
            当前等级,
            经验增加后的等级,
            升级可学会招式列表,
            会话
        )

        if 新招式列表:
            # move_services.生成学习新招式操作字典方法 会返回所有技能的删除和重写操作
            招式操作列表, 招式文案信息 = move_services.生成学习新招式操作字典方法(
                宝可梦ID,
                await move_services.返回招式数据方法(宝可梦ID, 会话),
                新招式列表
            )

            if 招式操作列表:
                # 招式操作列表包含：删除所有招式 + 插入旧招式 + 插入新招式
                操作列表.extend(招式操作列表)
                文案信息字典.update(招式文案信息)
                文案信息字典["是否学习"] = True

    # 构造宝可梦基本属性更新操作
    宝可梦更新字典 = {
        "表名": 表名类.宝可梦表,
        "操作": 操作类.更新,
        "数据": 更新数据,
        "条件": {"主键ID": 宝可梦ID}
    }

    # 将核心的宝可梦更新操作放在第一个，确保经验和编号更新是事务的一部分
    操作列表.insert(0, 宝可梦更新字典)

    # 返回所有操作和文案信息，供上层进行统一的事务写入和文案拼接
    return result.结果类.成功方法((操作列表, 文案信息字典))
