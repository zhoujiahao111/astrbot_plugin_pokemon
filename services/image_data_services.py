# coding=utf-8
import os.path
from PIL import Image as PIL_Image, ImageDraw
from datetime import datetime
import random

from ..models import result, emptyMove
from ..game import pokemon
from ..utils import image_utils, text_utils
from ..services import pokemon_services, bag_services
from ..models.session import 会话类

# 满血状态下，填充物图片内的坐标 (左上, 右上, 右下, 左下)
FULL_HEALTH_VERTICES = {
    "本方": [(3, 1), (323, 1), (346, 23), (26, 23)],
    "对方": [(25, 1), (346, 1), (324, 23), (4, 23)]
}

def 生成宝可梦队列信息配置方法(
    数据信息: dict,
    昵称: str,
    队伍名称: str,
    会话: 会话类,
    队伍真实序号: int
) -> result.结果类:
    图片生成信息字典 = {
        "背景图": "队伍信息背景.jpg",
    }

    图片元素 = []
    文字元素 = [
        {
            "内容": f"训练家: {昵称}",
            "位置": (50, 10),
            "大小": 28,
            "颜色": (224, 224, 224),
            "图层": 1
        },
        {
            "内容": f"队伍序号: {队伍真实序号}",
            "位置": (50, 55),
            "大小": 28,
            "颜色": (224, 224, 224),
            "图层": 1
        },
        {
            "内容": f"队伍名称: {队伍名称}",
            "位置": (230, 55),
            "大小": 28,
            "颜色": (224, 224, 224),
            "图层": 1
        },
        {
            "内容": str(datetime.now().strftime('%Y-%m-%d %H:%M:%S')),
            "位置": (950, 10),
            "大小": 30,
            "颜色": (224, 224, 224),
            "图层": 1
        }

    ]

    背景图片_基础x = 43
    背景图片_基础y = 103

    for 索引, 数据信息 in enumerate(数据信息):
        行 = 索引 // 2  # 0,1,2
        列 = 索引 % 2  # 0,1

        背景图片_x = 背景图片_基础x + 列 * 608  # 列间距
        背景图片_y = 背景图片_基础y + 行 * 180  # 行间距

        宝可梦对象 = pokemon.宝可梦类(
            会话=会话,
            宝可梦数据字典=数据信息,
            宝可梦图鉴信息=会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(数据信息['编号']),
            招式列表=emptyMove.空招式类()
        )

        图片元素 += [
            {
                "路径": "ui/半透明信息展示黑框.png",
                "位置": (背景图片_x, 背景图片_y),  # 第一个宝可梦框的位置
                "图层": 1
            },
            {
                "路径": f"pokemon/{宝可梦对象.贴图}",
                "位置": (背景图片_x + 197, 背景图片_y + 7),
                "大小": (150, 150),
                "图层": 2
            },
            {
                "路径": f"icons/{宝可梦对象.性别}_标识.png",
                "位置": (背景图片_x + 90, 背景图片_y + 42),
                "大小": (25, 25),
                "图层": 2
            }
        ]

        for 属性索引, 属性 in enumerate(宝可梦对象.宝可梦属性列表):
            图片元素.append(
                {
                    "路径": f"icons/{属性}.png",
                    "位置": ((背景图片_x + 375) + 属性索引 * 100, 背景图片_y + 12),
                    "大小": (92, 24),  # 80%大小
                    "图层": 2
                }
            )

        if 宝可梦对象.心情 >= 70:
            心情颜色 = (0, 255, 0)  # 纯绿色
        elif 宝可梦对象.心情 >= 40:
            心情颜色 = (255, 255, 0)  # 纯黄色
        else:
            心情颜色 = (255, 0, 0)  # 纯红色

        文字元素 += [
            {
                "内容": 宝可梦对象.昵称,
                "位置": (背景图片_x + 17, 背景图片_y + 5),
                "大小": 25,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"LV {宝可梦对象.等级}",
                "位置": (背景图片_x + 17, 背景图片_y + 40),
                "大小": 20,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"天赋: {宝可梦对象.天赋描述}",
                "位置": (背景图片_x + 17, 背景图片_y + 72),
                "大小": 20,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"性格: {宝可梦对象.性格}",
                "位置": (背景图片_x + 17, 背景图片_y + 100),
                "大小": 19,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"心情: ",
                "位置": (背景图片_x + 17, 背景图片_y + 128),
                "大小": 19,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": 宝可梦对象.心情,
                "位置": (背景图片_x + 75, 背景图片_y + 128),
                "大小": 19,
                "颜色": 心情颜色,
                "图层": 2
            },
            {
                "内容": f"成长速度: {宝可梦对象.成长速度}",
                "位置": (背景图片_x + 387, 背景图片_y + 40),
                "大小": 18,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"分类: {宝可梦对象.宝可梦分类}",
                "位置": (背景图片_x + 387, 背景图片_y + 66),
                "大小": 18,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"{'' if 宝可梦对象.极巨化贴图名称 else '不'}可极巨化",
                "位置": (背景图片_x + 387, 背景图片_y + 91),
                "大小": 18,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": f"{'' if 宝可梦对象.mega贴图名称 else '不'}可mega",
                "位置": (背景图片_x + 387, 背景图片_y + 116),
                "大小": 18,
                "颜色": (255, 255, 255),
                "图层": 2
            },
            {
                "内容": str(索引 + 1),
                "位置": (背景图片_x + 547, 背景图片_y + 87),
                "大小": 52,
                "颜色": (220, 220, 背景图片_y + 87),
                "图层": 2,
                "倾斜": 60
            }
        ]

    图片生成信息字典["图片元素"] = 图片元素
    图片生成信息字典["文字元素"] = 文字元素

    return result.结果类.成功方法(图片生成信息字典)


def 生成背包图片信息方法(物品信息列表: list) -> result.结果类:
    # 先基于列表长度生成背景图片
    结果 = image_utils.读取图片方法(
        类别="ui",
        名称="背包_顶部.jpg",
    )

    if 结果.是否成功:
        背包顶部 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("背包贴图丢失了")

    结果 = image_utils.读取图片方法(
        类别="ui",
        名称="背包_一行.jpg",
    )

    if 结果.是否成功:
        背包一行 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("背包贴图丢失了")

    背包顶部宽度, 背包顶部高度 = 背包顶部.size
    背包一行宽度, 背包一行高度 = 背包一行.size

    # 粘贴多个背包一行, 额外一行是为了好看
    物品行数 = (len(物品信息列表) // 4) + 1

    # 计算新图片高度
    新图片高度 = 背包顶部高度 + 物品行数 * 背包一行高度

    背景图片 = PIL_Image.new('RGB', (背包顶部宽度, 新图片高度))

    # 粘贴背包顶部
    背景图片.paste(背包顶部, (0, 0))

    for i in range(物品行数 + 1):
        垂直位置 = 背包顶部高度 + i * 背包一行高度
        背景图片.paste(背包一行, (0, 垂直位置))

    图片元素 = []
    文字元素 = []
    # 480是背景图片宽度, 75是一格宽度 ,4是一行有4格, 5是左右+格子之间的间隔总数
    水平间隔 = (480 - (75 * 4)) // 5

    for 索引, 物品信息 in enumerate(物品信息列表):
        行号 = 索引 // 4
        列号 = 索引 % 4

        格子x = 水平间隔 + 列号 * (75 + 水平间隔)
        格子y = 背包顶部高度 + 行号 * 180

        图片元素 += [
            {
                "路径": "ui/背包_一格.jpg",
                "位置": (格子x, 格子y),
                "图层": 1
            },
            {
                "路径": f"goods/{物品信息['物品名称']}.png",
                "位置": (格子x + 8, 格子y + 10),
                "大小": (60, 60),
                "图层": 2
            }
        ]

        数量x偏移 = 60 - (10 * len(str(物品信息["数量"])) - 1)

        文字元素 += [
            {
                "内容": str(物品信息["数量"]),
                "位置": (格子x + 数量x偏移, 格子y + 75),
                "大小": 22,
                "颜色": (42, 42, 42),
                "图层": 2
            },
            {
                "内容": 物品信息["物品名称"],
                "位置": (格子x, 格子y + 115),
                "大小": 19,
                "颜色": (126, 84, 43),
                "图层": 2
            }
        ]

    return result.结果类.成功方法({
        "背景图": 背景图片,
        "图片元素": 图片元素,
        "文字元素": 文字元素
    })


def 生成宝可梦盒子信息配置方法(
    盒子宝可梦信息列表: list,
    会话: 会话类,
    页数: int,
    最终页: int
) -> result.结果类:
    结果 = image_utils.读取图片方法(
        类别="ui",
        名称="盒子_顶部.jpg",
    )

    if 结果.是否成功:
        盒子顶部 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("盒子贴图丢失了")

    结果 = image_utils.读取图片方法(
        类别="ui",
        名称="盒子_一行.jpg",
    )

    if 结果.是否成功:
        盒子一行 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("盒子贴图丢失了")

    盒子顶部宽度, 盒子顶部高度 = 盒子顶部.size
    盒子一行宽度, 盒子一行高度 = 盒子一行.size

    # 计算新图片高度, 最大行数是 6
    新图片高度 = 盒子顶部高度 + 5 * 盒子一行高度 + 盒子一行高度 // 2

    背景图片 = PIL_Image.new('RGB', (盒子顶部宽度, 新图片高度))

    # 粘贴盒子顶部
    背景图片.paste(盒子顶部, (0, 0))

    # 最大行数是 6, 物品占5行
    for i in range(6):
        垂直位置 = 盒子顶部高度 + i * 盒子一行高度
        背景图片.paste(盒子一行, (0, 垂直位置))

    图片元素 = []
    文字元素 = []

    # 180是一格宽度 ,4是一行有4格, 5是左右+格子之间的间隔总数
    水平间隔 = ((盒子顶部宽度 - (180 * 4)) // 5) - 5

    每页数量 = 20
    起始索引 = (页数 - 1) * 每页数量

    for 索引, 宝可梦信息 in enumerate(盒子宝可梦信息列表[起始索引: 起始索引 + 20]):
        行号 = 索引 // 4
        列号 = 索引 % 4

        格子x = 水平间隔 + 列号 * (190 + 水平间隔)
        格子y = 盒子顶部高度 + 行号 * 盒子一行高度

        图片元素 += [
            {
                "路径": "ui/盒子_一格.jpg",
                "位置": (格子x, 格子y),
                "图层": 1
            },
            {
                "路径": f"pokemon/{会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(宝可梦信息['编号']).贴图}",
                "位置": (格子x + 10, 格子y + 10),
                "大小": (150, 150),
                "图层": 2
            }
        ]

        盒子序号x偏移 = 162 - (15 * len(str(宝可梦信息["盒子序号"])) - 5)

        等级 = pokemon_services.返回宝可梦等级方法(
            会话,
            宝可梦信息["经验"],
            宝可梦信息["成长速度"]
        )

        文字元素 += [
            {
                "内容": (20 * (页数 - 1)) + 索引 + 1,
                "位置": (格子x + 盒子序号x偏移, 格子y + 132),
                "大小": 28,
                "颜色": (126, 84, 43),
                "图层": 2
            },
            {
                "内容": 宝可梦信息["昵称"],
                "位置": (格子x + 12, 格子y + 179),
                "大小": 24,
                "颜色": (126, 84, 43),
                "图层": 2
            }
            ,
            {
                "内容": f"Lv: {等级}",
                "位置": (格子x + 14, 格子y + 206),
                "大小": 24,
                "颜色": (126, 84, 43),
                "图层": 2
            },
            {
                "内容": f'天赋: {pokemon_services.返回天赋值对应描述文本(int(宝可梦信息["天赋"]))}',
                "位置": (格子x + 10, 格子y + 236),
                "大小": 24,
                "颜色": (126, 84, 43),
                "图层": 2
            }
        ]

    if 页数 == 1:
        页码文本 = f"{页数} -->"
        位置 = 385
    elif 页数 >= 最终页:
        页码文本 = f"<-- {最终页}"
        数字起始位置 = 400 - (4 * 14.4)
        前缀宽度 = len("<-- ") * 14.4
        位置 = 数字起始位置 - 前缀宽度
    else:
        页码文本 = f"<-- {页数} -->"
        数字起始位置 = 370 - ((len(str(页数)) * 14.4) / 2)
        前缀宽度 = len("<-- ") * 14.4
        位置 = 数字起始位置 - 前缀宽度

    文字元素 += [
        {
            "内容": 页码文本,
            "位置": (int(位置), 新图片高度 - 100),
            "大小": 48,
            "颜色": (126, 84, 43),
            "图层": 2
        }
    ]

    return result.结果类.成功方法({
        "背景图": 背景图片,
        "图片元素": 图片元素,
        "文字元素": 文字元素
    })


def 生成队伍列表信息配置方法(
    会话: 会话类,
    数据信息列表: list,
    页数: int
) -> result.结果类:
    结果 = image_utils.读取图片方法(
        类别="ui",
        名称="所有队伍_顶部.jpg",
    )

    if 结果.是否成功:
        队伍顶部 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("队伍列表贴图丢失了")

    队伍顶部宽度, 队伍顶部高度 = 队伍顶部.size

    # 预估图片高度
    新图片高度 = 队伍顶部高度 + 55  # 初始包含底部空间
    for 信息 in 数据信息列表:
        if 信息["宝可梦列表"] and len(信息["宝可梦列表"]) > 3:
            新图片高度 += 520
        else:
            新图片高度 += 340

    背景图片 = PIL_Image.new('RGB', (队伍顶部宽度, 新图片高度))

    # 粘贴盒子顶部
    背景图片.paste(队伍顶部, (0, 0))

    填充区域 = PIL_Image.new('RGB', (队伍顶部宽度, 新图片高度 - 队伍顶部高度), color=(213, 175, 121))
    背景图片.paste(填充区域, (0, 队伍顶部高度))

    图片元素 = []
    文字元素 = []

    格子y = 队伍顶部高度

    for 索引, 信息 in enumerate(数据信息列表):
        标题 = f"{(页数 - 1) * 4 + 索引 + 1}号队伍 {信息['队伍名称']}"
        标题x = (队伍顶部宽度 // 2) - (len(标题) * 15.5)

        文字元素 += [
            {
                "内容": 标题,
                "位置": (标题x, 格子y + 65),
                "大小": 32,
                "颜色": (126, 84, 43),
                "图层": 2
            }
        ]

        if 信息["宝可梦列表"]:
            图片元素.append({
                "路径": "ui/所有队伍_边框.jpg" if len(信息["宝可梦列表"]) > 3 else "ui/所有队伍_边框_半高.jpg",
                "位置": (0, 格子y),
                "图层": 1
            })

            宝可梦图片尺寸 = 120
            图片间横向间距 = 60
            图片间纵向间距 = 50
            整体左边距 = (队伍顶部宽度 - (宝可梦图片尺寸 * 3 + 图片间横向间距 * 2)) // 2
            宝可梦区域顶部边距 = 100

            for 宝可梦索引, 宝可梦信息 in enumerate(信息["宝可梦列表"]):
                行号 = 宝可梦索引 // 3
                列号 = 宝可梦索引 % 3

                x偏移 = 整体左边距 + 列号 * (宝可梦图片尺寸 + 图片间横向间距)
                y偏移 = 格子y + 宝可梦区域顶部边距 + 行号 * (宝可梦图片尺寸 + 图片间纵向间距)

                try:
                    贴图路径 = 会话.json管理器.宝可梦图鉴.根据编号获取宝可梦(宝可梦信息['编号']).贴图
                except Exception as e:
                    return result.结果类.失败方法("贴图路径错误: " + str(e))

                图片元素.append({
                    "路径": f"pokemon/{贴图路径}",
                    "位置": (x偏移, y偏移),
                    "大小": (宝可梦图片尺寸, 宝可梦图片尺寸),  # 使用变量使其更清晰
                    "图层": 2
                })

                等级 = pokemon_services.返回宝可梦等级方法(
                    会话,
                    宝可梦信息["经验"],
                    宝可梦信息["成长速度"]
                )

                文字元素 += [
                    {
                        "内容": 宝可梦信息['昵称'],
                        "位置": (x偏移 + 30, y偏移 + 120),
                        "大小": 20,
                        "颜色": (126, 84, 43),
                        "图层": 2
                    },
                    {
                        "内容": f"Lv {等级}",
                        "位置": (x偏移 + 30, y偏移 + 142),
                        "大小": 18,
                        "颜色": (126, 84, 43),
                        "图层": 2
                    }
                ]
        else:
            # 队伍没有宝可梦
            图片元素.append({
                "路径": "ui/所有队伍_边框_半高.jpg",
                "位置": (0, 格子y),
                "图层": 1
            })

            文字元素 += [
                {
                    "内容": "-该队伍还没有宝可梦-",
                    "位置": (240, 格子y + 150),
                    "大小": 30,
                    "颜色": (110, 96, 77),
                    "图层": 2
                }
            ]

        if 信息["宝可梦列表"] and len(信息["宝可梦列表"]) > 3:
            格子y += 520
        else:
            格子y += 340

    文字元素 += [
        {
            "内容": f"-{页数}-",
            "位置": (370, 新图片高度 - 80),
            "大小": 39,
            "颜色": (126, 84, 43),
            "图层": 2
        }
    ]

    return result.结果类.成功方法({
        "背景图": 背景图片,
        "图片元素": 图片元素,
        "文字元素": 文字元素
    })

def 获取生命值颜色方法(当前生命值, 最大生命值) -> tuple:
    if 最大生命值 == 0:
        return (200, 200, 200)  # 如果最大生命值为0，返回灰色

    生命值比率 = 当前生命值 / 最大生命值

    if 生命值比率 > 0.5:
        # 从绿色 (144, 238, 144) 到 黄色 (255, 255, 0) 的过渡
        red = int((1.0 - (生命值比率 - 0.5) * 2) * 255 + ((生命值比率 - 0.5) * 2) * 144)
        green = int(255 * (1.0 - (生命值比率 - 0.5) * 2) + 238 * ((生命值比率 - 0.5) * 2))
        blue = int(0 * (1.0 - (生命值比率 - 0.5) * 2) + 144 * ((生命值比率 - 0.5) * 2))
    else:
        # 从黄色 (255, 255, 0) 到 橙红色 (255, 69, 0) 的过渡
        red = 255
        green = int(生命值比率 * 2 * 255 + (1 - 生命值比率 * 2) * 69)
        blue = 0

    return (red, green, blue)

def 生成战斗界面信息配置方法(
    本方昵称: str,
    对方昵称: str,
    背景图名称: str,
    左侧宝可梦数据: dict,
    右侧宝可梦数据: dict,
    本方队伍名称: str,
    对方队伍名称: str,
    本方队伍长度: int,
    对方队伍长度: int,
    本方开启mega: bool = False,
    本方开启极巨化: bool = False,
    对方开启mega: bool = False,
    对方开启极巨化: bool = False,
) -> result.结果类 | dict:
    def 计算镜像x坐标(基础x坐标: int, 容器宽度: int, 素材宽度: int, 索引: int) -> int:
        if 索引 == 0:
            return 基础x坐标
        else:
            return 容器宽度 - 基础x坐标 - 素材宽度

    结果 = image_utils.读取图片方法(
        类别="background",
        名称=背景图名称
    )

    if 结果.是否成功:
        基础背景图 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("背景图丢失了")

    结果 = image_utils.读取图片方法(类别="ui", 名称="本方血条填充物.png")
    if 结果.是否成功:
        本方血条填充物 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("本方血条贴图丢失了")

    结果 = image_utils.读取图片方法(类别="ui", 名称="对方血条填充物.png")
    if 结果.是否成功:
        对方血条填充物 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("对方血条贴图丢失了")

    结果 = image_utils.读取图片方法(类别="ui", 名称="底部信息框.png")

    if 结果.是否成功:
        底部信息框 = PIL_Image.open(结果.数据信息)
    else:
        return result.结果类.失败方法("底部信息框图丢失了")

    总高度 = 基础背景图.height + 底部信息框.height
    背景图 = PIL_Image.new('RGBA', (基础背景图.width, 总高度))

    背景图.paste(基础背景图, (0, 0))
    背景图.paste(底部信息框, (0, 基础背景图.height), 底部信息框)

    图片元素 = [{
                "路径": "ui/斜向精灵球_80px.png",
                "位置": (360, 22),
                "图层": 2
            }]
    文字元素 = []

    普通_大小 = (200, 200)
    普通_位置 = (30, 235)  # (基础x坐标, y坐标)

    mega_大小 = (230, 230)
    mega_位置 = (25, 215)

    极巨化_大小 = (300, 300)
    极巨化_位置 = (10, 145)

    # 定义缩放系数，用于一方极巨化时，缩小另一方
    # 0.75 表示缩小到原来的75%
    普通宝可梦_缩小系数 = 0.65
    # Mega宝可梦也需要缩小，但比普通缩小的幅度小一些 (例如85%)
    mega宝可梦_缩小系数 = 0.85

    场上存在极巨化 = 本方开启极巨化 or 对方开启极巨化

    for 索引, 宝可梦数据 in enumerate((左侧宝可梦数据, 右侧宝可梦数据)):
        # 生成属性雷达图
        结果 = image_utils.返回雷达属性图(
            属性字典=宝可梦数据["当前属性字典"],
            大小=(265, 265)
        )

        if 结果.是否成功:
            雷达图 = 结果.数据信息
        else:
            return 结果.失败方法(结果.错误信息)

        是mega状态 = (本方开启mega and 索引 == 0) or (对方开启mega and 索引 == 1)
        是极巨化状态 = (本方开启极巨化 and 索引 == 0) or (对方开启极巨化 and 索引 == 1)

        # 根据自身状态，选择一套基础参数
        if 是极巨化状态:
            宝可梦贴图 = f"pokemon_gigantamax/{宝可梦数据['极巨化贴图名称']}"
            当前_大小 = list(极巨化_大小)  # 转为列表方便后续修改
            当前_基础x = 极巨化_位置[0]
            当前_y坐标 = 极巨化_位置[1]

        elif 是mega状态:
            宝可梦贴图 = f"pokemon_mega/{宝可梦数据['mega贴图名称']}"
            当前_大小 = list(mega_大小)
            当前_基础x = mega_位置[0]
            当前_y坐标 = mega_位置[1]

        else:  # 普通状态
            宝可梦贴图 = f"pokemon/{宝可梦数据['贴图']}"
            当前_大小 = list(普通_大小)
            当前_基础x = 普通_位置[0]
            当前_y坐标 = 普通_位置[1]

        # 如果场上有极巨化，但自己不是，则缩小自己
        if 场上存在极巨化 and not 是极巨化状态:

            # 根据当前宝可梦是Mega还是普通，应用不同的缩小系数
            if 是mega状态:
                缩放系数 = mega宝可梦_缩小系数
            else:
                缩放系数 = 普通宝可梦_缩小系数

            当前_大小[0] = int(当前_大小[0] * 缩放系数)
            当前_大小[1] = int(当前_大小[1] * 缩放系数)

            当前_y坐标 += 25

        宝可梦贴图大小 = tuple(当前_大小)  # 将列表转回元组

        # 使用最终计算出的大小来确定素材宽度，这样x坐标计算才能准确
        素材宽度 = 宝可梦贴图大小[0]
        宝可梦贴图位置 = (计算镜像x坐标(基础x坐标=当前_基础x, 容器宽度=800, 素材宽度=素材宽度, 索引=索引), 当前_y坐标)

        生命值比率 = 宝可梦数据["当前生命值"] / 宝可梦数据["当前属性字典"]["HP"]

        if 索引 == 1:  # 对方
            填充物 = 对方血条填充物
            # 获取对方满血时的四个顶点
            v_tl, v_tr, v_br, v_bl = FULL_HEALTH_VERTICES["对方"]
        else:  # 我方
            填充物 = 本方血条填充物
            # 获取我方满血时的四个顶点
            v_tl, v_tr, v_br, v_bl = FULL_HEALTH_VERTICES["本方"]

        # 动态创建遮罩
        遮罩 = PIL_Image.new("L", 填充物.size, 0)
        draw = ImageDraw.Draw(遮罩)

        if 索引 == 1:  # 对方 (从右向左缩短)
            # 计算新的左上角顶点
            new_tl = lerp(v_tr, v_tl, 生命值比率)
            # 计算新的左下角顶点
            new_bl = lerp(v_br, v_bl, 生命值比率)

            # 定义最终的顶点列表
            vertices = [new_tl, v_tr, v_br, new_bl]

        else:  # 我方 (从左向右增长)
            # 计算新的右上角顶点
            new_tr = lerp(v_tl, v_tr, 生命值比率)
            # 计算新的右下角顶点
            new_br = lerp(v_bl, v_br, 生命值比率)

            # 定义最终的顶点列表
            vertices = [v_tl, new_tr, new_br, v_bl]

        # 使用 polygon 方法绘制精确的遮罩
        int_vertices = [(int(p[0]), int(p[1])) for p in vertices]
        draw.polygon(int_vertices, fill=255)

        血条位置 = (计算镜像x坐标(基础x坐标=16, 容器宽度=800, 素材宽度=347, 索引=索引), 57)

        图片元素 += [
            {
                "路径": f"ui/{'对' if 索引 else '本'}方血条容器.png",
                "位置": 血条位置,
                "图层": 1
            },
            {
                "路径": (对方血条填充物 if 索引 else 本方血条填充物),  # 直接传入PIL对象
                "位置": 血条位置,
                "遮罩": 遮罩,
                "图层": 2
            },
            {
                "路径": 宝可梦贴图,
                "位置": 宝可梦贴图位置,
                "大小": 宝可梦贴图大小,
                "镜像": False if 索引 else True,
                "图层": 1
            },
            {
                "路径": 雷达图,
                "位置": (计算镜像x坐标(基础x坐标=22, 容器宽度=800, 素材宽度=260, 索引=索引), 525),
                # "位置": (22, 535),
                "图层": 2
            },
            {
                "路径": "ui/精灵球栏位.png",
                "位置": (计算镜像x坐标(基础x坐标=20, 容器宽度=800, 素材宽度=200, 索引=索引), 440),
                "图层": 2
            },
        ]

        文字元素 += [
            {
                "内容": 对方昵称 if 索引 else 本方昵称,
                "位置": (
                    max(
                        450 if 索引 else 20,
                        计算镜像x坐标(基础x坐标=20, 容器宽度=800, 素材宽度=(len(对方昵称 if 索引 else 本方昵称) * 30)+10, 索引=索引)
                    ),
                    18
                ),
                "大小": 32,
                "颜色": (255, 255, 255),
                "描边宽度": 4,
                "描边颜色": (0, 0, 0),
                "图层": 1
            },
            {
                "内容": 对方队伍名称 if 索引 else 本方队伍名称,
                "位置": (计算镜像x坐标(基础x坐标=20, 容器宽度=800, 素材宽度=len(本方队伍名称) * 26, 索引=索引), 75),
                "大小": 26,
                "颜色": (255, 255, 255),
                "描边宽度": 2,
                "描边颜色": (0, 0, 0),
                "图层": 1
            },
            {
                "内容": str(int(宝可梦数据["当前生命值"])),
                "位置": (计算镜像x坐标(基础x坐标=300, 容器宽度=800, 素材宽度=len(str(宝可梦数据["当前属性字典"]["HP"])) * 32 - 28, 索引=索引), 18),
                "大小": 48,
                "颜色": 获取生命值颜色方法(宝可梦数据["当前生命值"], 宝可梦数据["当前属性字典"]["HP"]),
                "描边宽度": 3,
                "描边颜色": (0, 0, 0),
                "图层": 2
            }
        ]

        # 添加招式名称
        for 招式索引, 招式名称 in enumerate(宝可梦数据["招式名称列表"]):
            文字元素.append(
                {
                    "内容": 招式名称,
                    "位置": (计算镜像x坐标(基础x坐标=280, 容器宽度=800, 素材宽度=80, 索引=索引), 555 + 招式索引 * 50),
                    "大小": 20,
                    "颜色": (255, 255, 255),
                    "图层": 2
                }
            )

        # 添加精灵球, 数量来自双方队伍的宝可梦数量
        for 精灵球索引 in range(对方队伍长度 if 索引 else 本方队伍长度):
            图片元素.append(
                {
                    "路径": "ui/精灵球_40px.png",
                    "位置": (计算镜像x坐标(
                        基础x坐标=30 + 精灵球索引 * 32,
                        容器宽度=800,
                        素材宽度=20,
                        索引=索引
                    ), 445),
                    "大小": (28, 28),
                    "图层": 2
                }
            )

    return result.结果类.成功方法({
        "背景图": 背景图,
        "图片元素": 图片元素,
        "文字元素": 文字元素
    })

# 辅助函数, 计算点p1和点p2连线上，比率为ratio的位置
def lerp(p1, p2, ratio):
    return (
        p1[0] + (p2[0] - p1[0]) * ratio,
        p1[1] + (p2[1] - p1[1]) * ratio
    )

def 返回背景图名称():
    背景图文件夹路径 = os.path.join(
        os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            'data',
            'images',
            'background',
        )
    )

    return random.choice(os.listdir(背景图文件夹路径))