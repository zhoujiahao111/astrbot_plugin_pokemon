核心设计目标

统一入口：接收用户输入（道具名 + 数量 + session）。

解耦逻辑：

道具定义层：json 配置，描述道具规则和效果。

效果执行层：不同效果对应不同处理类。

调度层：统一调度器，负责解析效果列表并生成数据库操作字典。

可扩展性：效果类型可新增/下架，只需新增类，不动主框架。

事务化写入：不在中途执行 SQL，统一返回操作字典列表，最后一次性写入数据库。

多效果支持：道具可包含多个效果，依次生成对应操作字典。

容错性：某个效果失败时，能明确反馈，避免 silent fail。

📂 推荐文件结构

新增一个文件：

game/items/
  ├── base_effect.py     # 效果基类
  ├── effects.py         # 具体效果类：即时捕获/全队心情恢复/限时状态 等
  ├── item_service.py    # 使用物品入口逻辑
  └── __init__.py

🧩 方案细节
1. 效果基类
# game/items/base_effect.py
from models.result import 结果类

class 基础效果:
    def __init__(self, 道具信息: dict, 效果参数: dict, 会话):
        self.道具信息 = 道具信息
        self.效果参数 = 效果参数
        self.会话 = 会话

    async def 生成操作(self) -> 结果类[list[dict]]:
        """生成数据库操作字典列表（不执行）"""
        raise NotImplementedError

2. 效果实现
# game/items/effects.py
from game.items.base_effect import 基础效果
from models.result import 结果类

class 即时捕获效果(基础效果):
    async def 生成操作(self):
        捕获率 = self.效果参数.get("基础捕获率", 0.5)
        return 结果类.成功方法([
            {
                "表名": "捕获日志表",
                "操作": "插入",
                "数据": {
                    "用户ID": self.会话.用户qq,
                    "捕获率": 捕获率,
                    "道具ID": self.道具信息["标识ID"]
                }
            }
        ])

class 添加限时状态效果(基础效果):
    async def 生成操作(self):
        return 结果类.成功方法([
            {
                "表名": "状态表",
                "操作": "插入",
                "数据": {
                    "用户ID": self.会话.用户qq,
                    "状态类型": self.效果参数["状态类型"],
                    "持续时间": self.效果参数["持续时间"],
                    "加成类型": self.效果参数["加成类型"],
                    "加成值": self.效果参数["加成值"]
                }
            }
        ])


（其它效果如 "全队心情恢复", "全队升级", "解锁mega/极巨化状态" 可以用相同模式扩展）

3. 效果调度器
# game/items/item_service.py
from game.items.effects import 即时捕获效果, 添加限时状态效果
from models.result import 结果类

效果映射 = {
    "即时捕获": 即时捕获效果,
    "添加限时状态": 添加限时状态效果,
    # "全队心情恢复": 全队心情恢复效果,
    # "全队升级": 全队升级效果,
    # "解锁mega/极巨化状态": Mega效果类,
}

async def 使用物品(会话, 道具信息: dict, 数量: int):
    操作列表 = []

    # 检查可使用性
    使用规则 = 道具信息.get("使用规则", {})
    if not 使用规则.get("可主动使用", True):
        return 结果类.失败方法(f"道具 {道具信息['名称']} 不能主动使用")

    # 遍历效果列表
    for 效果 in 道具信息.get("效果列表", []):
        效果类型 = 效果["效果类型"]
        效果参数 = 效果["效果参数"]

        if 效果类型 not in 效果映射:
            return 结果类.失败方法(f"未知效果: {效果类型}")

        处理类 = 效果映射[效果类型](道具信息, 效果参数, 会话)
        结果 = await 处理类.生成操作()
        if not 结果.是否成功:
            return 结果
        操作列表.extend(结果.数据信息)

    # 添加减少物品操作
    if 使用规则.get("消耗方式") == "次数":
        操作列表.append({
            "表名": "背包表",
            "操作": "更新",
            "数据": {"数量": f"-{数量}"},
            "条件": {"用户ID": 会话.用户qq, "道具ID": 道具信息["标识ID"]}
        })

    return 结果类.成功方法(操作列表)

4. 调用流程
# 某个指令处理器
@装饰器函数()
async def 使用道具指令(会话, 道具名: str, 数量: int = 1):
    道具信息 = ... # 从json_manager获取道具信息，已做模糊匹配
    结果 = await 使用物品(会话, 道具信息, 数量)

    if not 结果.是否成功:
        return await 会话.回复(结果.错误信息)

    # 统一提交数据库
    await db.写入方法(结果.数据信息)
    return await 会话.回复(f"成功使用 {道具名} x{数量}")

🔑 特点

解耦：效果逻辑独立在 effects.py，新增/下架只改映射。

多效果支持：遍历 效果列表，依次生成操作。

一次性写入：统一返回 操作列表 → db.写入方法。

扩展性：以后可以在 item_service.py 扩展如：组合效果、互斥检查、优先级处理。

核心其实是：

拓展性：随时加新效果类，减少动核心逻辑的需求。

兼容性：老的效果词条能继续用。

安全性：即使效果冲突、不合法参数也不能导致致命报错。

战斗联动：涉及宝可梦时，应该能通过实例化宝可梦类，利用已有的计算代码（等级、属性修正、经验值转换等）。

并发安全：虽然道具使用和战斗是不同协程，但数据库统一写入，战斗回合逻辑读取时自然能感知变化。

我给你一个更完整的方案，重点增加 冲突检测层 和 宝可梦实例化层。

⚙️ 核心设计升级
1. 效果调度流程图
入口方法
  ↓
道具json → 使用规则检查
  ↓
for 效果 in 效果列表:
    实例化效果类(道具信息, 效果参数, 会话, [目标宝可梦])
    ↓
    调用效果类的 校验方法()
        - 参数完整性检查
        - 冲突检测（如已有同类状态）
        - 合法性检查（如等级上限）
    ↓
    如果校验通过 → 生成操作字典
    如果校验失败 → 返回警告/失败
  ↓
汇总操作字典列表
  ↓
追加“减少物品”操作
  ↓
返回结果类(操作列表)

2. 效果基类增强
# game/items/base_effect.py
from models.result import 结果类

class 基础效果:
    def __init__(self, 道具信息: dict, 效果参数: dict, 会话, 目标宝可梦=None):
        self.道具信息 = 道具信息
        self.效果参数 = 效果参数
        self.会话 = 会话
        self.目标宝可梦 = 目标宝可梦  # 可选，涉及属性计算时传入

    async def 校验(self) -> 结果类[None]:
        """冲突检测、合法性检查，默认通过"""
        return 结果类.成功方法(None)

    async def 生成操作(self) -> 结果类[list[dict]]:
        raise NotImplementedError

3. 冲突检测举例
限时状态（避免叠加）
class 添加限时状态效果(基础效果):
    async def 校验(self):
        # 查询数据库是否已有同类状态
        结果 = await db.单次查询方法({
            "表名": "状态表",
            "查询数据": ["状态类型", "加成类型"],
            "条件": {"用户ID": self.会话.用户qq}
        })

        if 结果.是否成功:
            for row in 结果.数据信息:
                if (row["状态类型"] == self.效果参数["状态类型"]
                        and row["加成类型"] == self.效果参数["加成类型"]):
                    return 结果类.失败方法("已有同类状态，不能重复使用")
        return 结果类.成功方法(None)

    async def 生成操作(self):
        return 结果类.成功方法([{
            "表名": "状态表",
            "操作": "插入",
            "数据": {
                "用户ID": self.会话.用户qq,
                "状态类型": self.效果参数["状态类型"],
                "持续时间": self.效果参数["持续时间"],
                "加成类型": self.效果参数["加成类型"],
                "加成值": self.效果参数["加成值"]
            }
        }])

4. 宝可梦实例化层

涉及宝可梦的效果，比如「全队升级」「即时捕获」，应该调用 game/pokemon.py 提供的类。

from game.pokemon import 宝可梦类

class 全队升级效果(基础效果):
    async def 校验(self):
        # 检查是否有队伍
        结果 = await db.单次查询方法({
            "表名": "队伍信息表",
            "查询数据": ["宝可梦ID"],
            "条件": {"用户ID": self.会话.用户qq}
        })
        if not 结果.是否成功 or not 结果.数据信息:
            return 结果类.失败方法("没有队伍，无法使用全队升级")
        return 结果类.成功方法(None)

    async def 生成操作(self):
        操作列表 = []
        队伍数据 = await db.单次查询方法({
            "表名": "队伍信息表",
            "查询数据": ["宝可梦ID"],
            "条件": {"用户ID": self.会话.用户qq}
        })
        for row in 队伍数据.数据信息:
            宝可梦 = await 宝可梦类.from_db(row["宝可梦ID"])  # 假设已有方法构造实例
            新经验 = 宝可梦.经验值 + self.效果参数.get("经验加成", 1000)
            操作列表.append({
                "表名": "宝可梦表",
                "操作": "更新",
                "数据": {"经验值": 新经验},
                "条件": {"宝可梦ID": row["宝可梦ID"]}
            })
        return 结果类.成功方法(操作列表)

5. 调度器增强
async def 使用物品(会话, 道具信息: dict, 数量: int):
    操作列表 = []
    使用规则 = 道具信息.get("使用规则", {})

    if not 使用规则.get("可主动使用", True):
        return 结果类.失败方法(f"道具 {道具信息['名称']} 不能主动使用")

    for 效果 in 道具信息.get("效果列表", []):
        效果类型 = 效果["效果类型"]
        效果参数 = 效果["效果参数"]

        if 效果类型 not in 效果映射:
            return 结果类.失败方法(f"未知效果: {效果类型}")

        处理类 = 效果映射[效果类型](道具信息, 效果参数, 会话)
        校验结果 = await 处理类.校验()
        if not 校验结果.是否成功:
            return 校验结果

        结果 = await 处理类.生成操作()
        if not 结果.是否成功:
            return 结果

        操作列表.extend(结果.数据信息)

    if 使用规则.get("消耗方式") == "次数":
        操作列表.append({
            "表名": "背包表",
            "操作": "更新",
            "数据": {"数量": f"-{数量}"},
            "条件": {"用户ID": 会话.用户qq, "道具ID": 道具信息["标识ID"]}
        })

    return 结果类.成功方法(操作列表)

🔑 优点

拓展性：新增效果只需新建类 + 注册映射。

兼容性：老的效果仍能用，只是多了 校验() 步骤。

安全性：冲突检测在 校验()，不会直接报错，而是返回失败信息。

战斗联动：道具效果改变数据库后，战斗每回合计算属性时自然能反映。

并发安全：协程分离，但最终由数据库状态一致性保证。
